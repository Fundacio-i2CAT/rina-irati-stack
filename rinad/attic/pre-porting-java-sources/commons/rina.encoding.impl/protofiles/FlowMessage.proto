package rina.messages;
option java_package="rina.encoding.impl.googleprotobuf.flow";
import "protofiles/ApplicationProcessNamingInfoMessage.proto";
import "protofiles/QoSSpecification.proto";
import "protofiles/PropertyMessage.proto";

message connectionId_t {  //information to identify a connection
	optional uint32 qosId = 1; 				//identifies the QoS cube under which this flow is classified
	optional uint32 sourceCEPId = 2; 		//identifies the source connection endpoint (unique within the source IPC process)
	optional uint32 destinationCEPId = 3; 	//identifies the destination connection endpoint (unique within the destination IPC process)
}

message policyParameter_t {  //the parameters of a policy configuration
    optional string name = 1;     //The name of the parameter
    optional string value = 2;    //The value of the parameter
}

message efcpPolicyConfig_t {  //configuration of an EFCP policy
	optional string name = 1;         //The name of the policy
	optional uint32 version = 2;      //The version of the policy
	repeated policyParameter_t parameters = 3;   //optional name/value parameters to configure the policy
}

message dtcpWindowBasedFlowControlConfig_t {  //the window-based flow control configuration of a connection
	optional uint64 maxclosedwindowqueuelength = 1;                 //Integer that the number PDUs that can be put on the ClosedWindowQueue before something must be done
	optional uint64 initialcredit = 2; 								//initial sequence number to get right window edge
	optional efcpPolicyConfig_t rcvrflowcontrolpolicy = 3;          //Invoked when a Transfer PDU is received to give the receiving PM an opportunity to update the flow control allocations
	optional efcpPolicyConfig_t receivingflowcontrolpolicy = 4;     //Allows some discretion in when to send a Flow Control PDU when there is no Retransmission Control
}

message dtcpRateBasedFlowControlConfig_t {  //the rate-based flow control configuration of a connection
	optional uint64 sendingrate = 1;                                //the number of PDUs that may be sent in a TimePeriod. Used with rate-based flow control
	optional uint64 timeperiod = 2;						            //length of time in microseconds for pacing rate-based flow control
	optional efcpPolicyConfig_t norateslowdownpolicy = 3;           //used to momentarily lower the send rate below the rate allowed
	optional efcpPolicyConfig_t nooverridedefaultpeakpolicy = 4;    //Allows rate-based flow control to exceed its nominal rate
	optional efcpPolicyConfig_t ratereductionpolicy = 5;            //Allows an alternate action when using rate-based flow control and the number of free buffers is getting low
}

message dtcpFlowControlConfig_t {  //the flow control configuration of a connection
	optional bool windowBased = 1;                                       //indicates whether window-based flow control is in use
	optional dtcpWindowBasedFlowControlConfig_t windowBasedConfig = 2;   //the window-based flow control configuration
	optional bool rateBased = 3;										 //indicates whether rate-based flow control is in use
	optional dtcpRateBasedFlowControlConfig_t rateBasedConfig = 4;       //the rate-based flow control configuration
	optional uint64 sentbytesthreshold = 5;							     //The number of free bytes below which flow control should slow or block the user from doing any more Writes
	optional uint64 sentbytespercentthreshold = 6;						 //The percent of free bytes below, which flow control should slow or block the user from doing any more Writes
	optional uint64 sentbuffersthreshold = 7;							 //The number of free buffers below which flow control should slow or block the user from doing any more Writes
	optional uint64 rcvbytesthreshold = 8;								 //The number of free bytes below which flow control does not move or decreases the amount the Right Window Edge is moved
	optional uint64 rcvbytespercentthreshold = 9;						 //The number of free buffers at which flow control does not advance or decreases the amount the Right Window Edge is moved.
	optional uint64 rcvbuffersthreshold = 10;						     //The percent of free buffers below which flow control should not advance or decreases the amount the Right Window Edge is moved
	optional efcpPolicyConfig_t closedwindowpolicy = 11;                 //Determine the action to be taken when the receiver has not extended more credit to allow the sender to send more PDUs
	optional efcpPolicyConfig_t flowcontroloverrunpolicy = 12;           //Determines what action to take if the receiver receives PDUs but the credit or rate has been exceeded
	optional efcpPolicyConfig_t reconcileflowcontrolpolicy = 13;         //Invoked when both Credit and Rate based flow control are in use and they disagree on whether the PM can send or receive data
}

message dtcpRtxControlConfig_t {  //the rtx control configuration of a connection
	optional uint32 datarxmsnmax = 1;                              //the number of times the retransmission of a PDU will be attempted before some other action must be taken
	optional uint32 initialATimer = 2;                             //maximum time that a receiver will wait before sending an Ack
    optional efcpPolicyConfig_t rttestimatorpolicy = 3;            //Executed by the sender to estimate the duration of the retx timer
    optional efcpPolicyConfig_t rtxtimerexpirypolicy = 4;          //Executed by the sender when a Retransmission Timer Expires
    optional efcpPolicyConfig_t senderackpolicy = 5;               //Executed by the sender and provides the Sender with some discretion on when PDUs may be deleted from the ReTransmissionQ
    optional efcpPolicyConfig_t recvingacklistpolicy = 6;          //
    optional efcpPolicyConfig_t rcvrackpolicy = 7;                 //Executed by the receiver of the PDU and provides some discretion in the action taken
    optional efcpPolicyConfig_t sendingackpolicy = 8;              //allows an alternate action when the A-Timer expires when DTCP is present.
    optional efcpPolicyConfig_t rcvrcontrolackpolicy = 9;          //Allows an alternate action when a Control Ack PDU is received
}

message dtcpConfig_t {  //configuration of DTCP for a connection
    optional bool flowControl = 1;                                 //indicates if flow control is enabled in this connection
    optional dtcpFlowControlConfig_t flowControlConfig = 2;        //the flow control configuration
    optional bool rtxControl = 3;                                  //inidicates if rtx control is enabled in this connection
    optional dtcpRtxControlConfig_t rtxControlConfig = 4;          //the rtx control configuration
    optional uint32 initialsenderinactivitytime = 5;               //should be approximately 2Δt. This must be bounded. 
    optional uint32 initialrecvrinactivitytime = 6;                //should be approximately 3Δt. This must be bounded.
    optional efcpPolicyConfig_t rcvrtimerinactivitypolicy = 7;     //If no PDUs arrive in this time period, the receiver should expect a DRF in the next Transfer PDU
    optional efcpPolicyConfig_t sendertimerinactiviypolicy = 8;    //This timer is used to detect long periods of no traffic, indicating that a DRF should be sent
    optional efcpPolicyConfig_t lostcontrolpdupolicy = 9;          //Determines what action to take when the PM detects that a control PDU (Ack or Flow Control) may have been lost
}

message connectionPolicies_t { //configuration of the policies and parameters of an EFCP connection
	optional bool dtcpPresent = 1;                          //indicates if this connection is using DTCP
	optional dtcpConfig_t dtcpConfiguration = 2;            //the DTCP Configuration for this connection
	optional efcpPolicyConfig_t initialseqnumpolicy = 3;    //allows some discretion in selecting the initial sequence number, when DRF is going to be sent
	optional uint64 seqnumrolloverthreshold = 4;            //the sequence number rollover threshold
}

message Flow{  //Contains the information to setup a new flow
	required rina.messages.applicationProcessNamingInfo_t sourceNamingInfo = 1;  			//The naming information of the source application process
	required rina.messages.applicationProcessNamingInfo_t destinationNamingInfo = 2; 		//The naming information of the destination application process
	required uint64 sourcePortId = 3; 										//The port id allocated to this flow by the source IPC process
	optional uint64 destinationPortId = 4; 									//The port id allocated to this flow by the destination IPC process
	required uint64 sourceAddress = 5; 										//The address of the source IPC process for this flow
	optional uint64 destinationAddress = 6; 									//The address of the destination IPC process for this flow
	repeated connectionId_t connectionIds = 7; 								//The identifiers of all the connections that can be used to support this flow during its lifetime
	optional uint32 currentConnectionIdIndex = 8;							//Identifies the index of the current active connection in the flow
	optional uint32 state = 9; 												//
	optional rina.messages.qosSpecification_t qosParameters = 10; 			//the QoS parameters specified by the application process that requested this flow
	optional connectionPolicies_t connectionPolicies = 11;                  //the configuration for the policies and parameters of this EFCP connection
	optional bytes accessControl = 12; 										// ?
	optional uint32 maxCreateFlowRetries = 13; 								//Maximum number of retries to create the flow before giving up
	optional uint32 createFlowRetries = 14; 								//The current number of retries
	optional uint32 hopCount = 15; 									        //While the search rules that generate the forwarding table should allow for a natural termination condition, it seems wise to have the means to enforce termination
}