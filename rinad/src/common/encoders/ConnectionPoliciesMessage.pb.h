// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ConnectionPoliciesMessage.proto

#ifndef PROTOBUF_ConnectionPoliciesMessage_2eproto__INCLUDED
#define PROTOBUF_ConnectionPoliciesMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "PolicyDescriptorMessage.pb.h"
// @@protoc_insertion_point(includes)

namespace rina {
namespace messages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ConnectionPoliciesMessage_2eproto();
void protobuf_AssignDesc_ConnectionPoliciesMessage_2eproto();
void protobuf_ShutdownFile_ConnectionPoliciesMessage_2eproto();

class dtcpWindowBasedFlowControlConfig_t;
class dtcpRateBasedFlowControlConfig_t;
class dtcpFlowControlConfig_t;
class dtcpRtxControlConfig_t;
class dtcpConfig_t;
class connectionPolicies_t;

// ===================================================================

class dtcpWindowBasedFlowControlConfig_t : public ::google::protobuf::Message {
 public:
  dtcpWindowBasedFlowControlConfig_t();
  virtual ~dtcpWindowBasedFlowControlConfig_t();

  dtcpWindowBasedFlowControlConfig_t(const dtcpWindowBasedFlowControlConfig_t& from);

  inline dtcpWindowBasedFlowControlConfig_t& operator=(const dtcpWindowBasedFlowControlConfig_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dtcpWindowBasedFlowControlConfig_t& default_instance();

  void Swap(dtcpWindowBasedFlowControlConfig_t* other);

  // implements Message ----------------------------------------------

  dtcpWindowBasedFlowControlConfig_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dtcpWindowBasedFlowControlConfig_t& from);
  void MergeFrom(const dtcpWindowBasedFlowControlConfig_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 maxclosedwindowqueuelength = 1;
  inline bool has_maxclosedwindowqueuelength() const;
  inline void clear_maxclosedwindowqueuelength();
  static const int kMaxclosedwindowqueuelengthFieldNumber = 1;
  inline ::google::protobuf::uint64 maxclosedwindowqueuelength() const;
  inline void set_maxclosedwindowqueuelength(::google::protobuf::uint64 value);

  // optional uint64 initialcredit = 2;
  inline bool has_initialcredit() const;
  inline void clear_initialcredit();
  static const int kInitialcreditFieldNumber = 2;
  inline ::google::protobuf::uint64 initialcredit() const;
  inline void set_initialcredit(::google::protobuf::uint64 value);

  // optional .rina.messages.policyDescriptor_t rcvrflowcontrolpolicy = 3;
  inline bool has_rcvrflowcontrolpolicy() const;
  inline void clear_rcvrflowcontrolpolicy();
  static const int kRcvrflowcontrolpolicyFieldNumber = 3;
  inline const ::rina::messages::policyDescriptor_t& rcvrflowcontrolpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_rcvrflowcontrolpolicy();
  inline ::rina::messages::policyDescriptor_t* release_rcvrflowcontrolpolicy();
  inline void set_allocated_rcvrflowcontrolpolicy(::rina::messages::policyDescriptor_t* rcvrflowcontrolpolicy);

  // optional .rina.messages.policyDescriptor_t txcontrolpolicy = 4;
  inline bool has_txcontrolpolicy() const;
  inline void clear_txcontrolpolicy();
  static const int kTxcontrolpolicyFieldNumber = 4;
  inline const ::rina::messages::policyDescriptor_t& txcontrolpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_txcontrolpolicy();
  inline ::rina::messages::policyDescriptor_t* release_txcontrolpolicy();
  inline void set_allocated_txcontrolpolicy(::rina::messages::policyDescriptor_t* txcontrolpolicy);

  // @@protoc_insertion_point(class_scope:rina.messages.dtcpWindowBasedFlowControlConfig_t)
 private:
  inline void set_has_maxclosedwindowqueuelength();
  inline void clear_has_maxclosedwindowqueuelength();
  inline void set_has_initialcredit();
  inline void clear_has_initialcredit();
  inline void set_has_rcvrflowcontrolpolicy();
  inline void clear_has_rcvrflowcontrolpolicy();
  inline void set_has_txcontrolpolicy();
  inline void clear_has_txcontrolpolicy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 maxclosedwindowqueuelength_;
  ::google::protobuf::uint64 initialcredit_;
  ::rina::messages::policyDescriptor_t* rcvrflowcontrolpolicy_;
  ::rina::messages::policyDescriptor_t* txcontrolpolicy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_AssignDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_ShutdownFile_ConnectionPoliciesMessage_2eproto();

  void InitAsDefaultInstance();
  static dtcpWindowBasedFlowControlConfig_t* default_instance_;
};
// -------------------------------------------------------------------

class dtcpRateBasedFlowControlConfig_t : public ::google::protobuf::Message {
 public:
  dtcpRateBasedFlowControlConfig_t();
  virtual ~dtcpRateBasedFlowControlConfig_t();

  dtcpRateBasedFlowControlConfig_t(const dtcpRateBasedFlowControlConfig_t& from);

  inline dtcpRateBasedFlowControlConfig_t& operator=(const dtcpRateBasedFlowControlConfig_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dtcpRateBasedFlowControlConfig_t& default_instance();

  void Swap(dtcpRateBasedFlowControlConfig_t* other);

  // implements Message ----------------------------------------------

  dtcpRateBasedFlowControlConfig_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dtcpRateBasedFlowControlConfig_t& from);
  void MergeFrom(const dtcpRateBasedFlowControlConfig_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 sendingrate = 1;
  inline bool has_sendingrate() const;
  inline void clear_sendingrate();
  static const int kSendingrateFieldNumber = 1;
  inline ::google::protobuf::uint64 sendingrate() const;
  inline void set_sendingrate(::google::protobuf::uint64 value);

  // optional uint64 timeperiod = 2;
  inline bool has_timeperiod() const;
  inline void clear_timeperiod();
  static const int kTimeperiodFieldNumber = 2;
  inline ::google::protobuf::uint64 timeperiod() const;
  inline void set_timeperiod(::google::protobuf::uint64 value);

  // optional .rina.messages.policyDescriptor_t norateslowdownpolicy = 3;
  inline bool has_norateslowdownpolicy() const;
  inline void clear_norateslowdownpolicy();
  static const int kNorateslowdownpolicyFieldNumber = 3;
  inline const ::rina::messages::policyDescriptor_t& norateslowdownpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_norateslowdownpolicy();
  inline ::rina::messages::policyDescriptor_t* release_norateslowdownpolicy();
  inline void set_allocated_norateslowdownpolicy(::rina::messages::policyDescriptor_t* norateslowdownpolicy);

  // optional .rina.messages.policyDescriptor_t nooverridedefaultpeakpolicy = 4;
  inline bool has_nooverridedefaultpeakpolicy() const;
  inline void clear_nooverridedefaultpeakpolicy();
  static const int kNooverridedefaultpeakpolicyFieldNumber = 4;
  inline const ::rina::messages::policyDescriptor_t& nooverridedefaultpeakpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_nooverridedefaultpeakpolicy();
  inline ::rina::messages::policyDescriptor_t* release_nooverridedefaultpeakpolicy();
  inline void set_allocated_nooverridedefaultpeakpolicy(::rina::messages::policyDescriptor_t* nooverridedefaultpeakpolicy);

  // optional .rina.messages.policyDescriptor_t ratereductionpolicy = 5;
  inline bool has_ratereductionpolicy() const;
  inline void clear_ratereductionpolicy();
  static const int kRatereductionpolicyFieldNumber = 5;
  inline const ::rina::messages::policyDescriptor_t& ratereductionpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_ratereductionpolicy();
  inline ::rina::messages::policyDescriptor_t* release_ratereductionpolicy();
  inline void set_allocated_ratereductionpolicy(::rina::messages::policyDescriptor_t* ratereductionpolicy);

  // @@protoc_insertion_point(class_scope:rina.messages.dtcpRateBasedFlowControlConfig_t)
 private:
  inline void set_has_sendingrate();
  inline void clear_has_sendingrate();
  inline void set_has_timeperiod();
  inline void clear_has_timeperiod();
  inline void set_has_norateslowdownpolicy();
  inline void clear_has_norateslowdownpolicy();
  inline void set_has_nooverridedefaultpeakpolicy();
  inline void clear_has_nooverridedefaultpeakpolicy();
  inline void set_has_ratereductionpolicy();
  inline void clear_has_ratereductionpolicy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 sendingrate_;
  ::google::protobuf::uint64 timeperiod_;
  ::rina::messages::policyDescriptor_t* norateslowdownpolicy_;
  ::rina::messages::policyDescriptor_t* nooverridedefaultpeakpolicy_;
  ::rina::messages::policyDescriptor_t* ratereductionpolicy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_AssignDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_ShutdownFile_ConnectionPoliciesMessage_2eproto();

  void InitAsDefaultInstance();
  static dtcpRateBasedFlowControlConfig_t* default_instance_;
};
// -------------------------------------------------------------------

class dtcpFlowControlConfig_t : public ::google::protobuf::Message {
 public:
  dtcpFlowControlConfig_t();
  virtual ~dtcpFlowControlConfig_t();

  dtcpFlowControlConfig_t(const dtcpFlowControlConfig_t& from);

  inline dtcpFlowControlConfig_t& operator=(const dtcpFlowControlConfig_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dtcpFlowControlConfig_t& default_instance();

  void Swap(dtcpFlowControlConfig_t* other);

  // implements Message ----------------------------------------------

  dtcpFlowControlConfig_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dtcpFlowControlConfig_t& from);
  void MergeFrom(const dtcpFlowControlConfig_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool windowBased = 1;
  inline bool has_windowbased() const;
  inline void clear_windowbased();
  static const int kWindowBasedFieldNumber = 1;
  inline bool windowbased() const;
  inline void set_windowbased(bool value);

  // optional .rina.messages.dtcpWindowBasedFlowControlConfig_t windowBasedConfig = 2;
  inline bool has_windowbasedconfig() const;
  inline void clear_windowbasedconfig();
  static const int kWindowBasedConfigFieldNumber = 2;
  inline const ::rina::messages::dtcpWindowBasedFlowControlConfig_t& windowbasedconfig() const;
  inline ::rina::messages::dtcpWindowBasedFlowControlConfig_t* mutable_windowbasedconfig();
  inline ::rina::messages::dtcpWindowBasedFlowControlConfig_t* release_windowbasedconfig();
  inline void set_allocated_windowbasedconfig(::rina::messages::dtcpWindowBasedFlowControlConfig_t* windowbasedconfig);

  // optional bool rateBased = 3;
  inline bool has_ratebased() const;
  inline void clear_ratebased();
  static const int kRateBasedFieldNumber = 3;
  inline bool ratebased() const;
  inline void set_ratebased(bool value);

  // optional .rina.messages.dtcpRateBasedFlowControlConfig_t rateBasedConfig = 4;
  inline bool has_ratebasedconfig() const;
  inline void clear_ratebasedconfig();
  static const int kRateBasedConfigFieldNumber = 4;
  inline const ::rina::messages::dtcpRateBasedFlowControlConfig_t& ratebasedconfig() const;
  inline ::rina::messages::dtcpRateBasedFlowControlConfig_t* mutable_ratebasedconfig();
  inline ::rina::messages::dtcpRateBasedFlowControlConfig_t* release_ratebasedconfig();
  inline void set_allocated_ratebasedconfig(::rina::messages::dtcpRateBasedFlowControlConfig_t* ratebasedconfig);

  // optional uint64 sentbytesthreshold = 5;
  inline bool has_sentbytesthreshold() const;
  inline void clear_sentbytesthreshold();
  static const int kSentbytesthresholdFieldNumber = 5;
  inline ::google::protobuf::uint64 sentbytesthreshold() const;
  inline void set_sentbytesthreshold(::google::protobuf::uint64 value);

  // optional uint64 sentbytespercentthreshold = 6;
  inline bool has_sentbytespercentthreshold() const;
  inline void clear_sentbytespercentthreshold();
  static const int kSentbytespercentthresholdFieldNumber = 6;
  inline ::google::protobuf::uint64 sentbytespercentthreshold() const;
  inline void set_sentbytespercentthreshold(::google::protobuf::uint64 value);

  // optional uint64 sentbuffersthreshold = 7;
  inline bool has_sentbuffersthreshold() const;
  inline void clear_sentbuffersthreshold();
  static const int kSentbuffersthresholdFieldNumber = 7;
  inline ::google::protobuf::uint64 sentbuffersthreshold() const;
  inline void set_sentbuffersthreshold(::google::protobuf::uint64 value);

  // optional uint64 rcvbytesthreshold = 8;
  inline bool has_rcvbytesthreshold() const;
  inline void clear_rcvbytesthreshold();
  static const int kRcvbytesthresholdFieldNumber = 8;
  inline ::google::protobuf::uint64 rcvbytesthreshold() const;
  inline void set_rcvbytesthreshold(::google::protobuf::uint64 value);

  // optional uint64 rcvbytespercentthreshold = 9;
  inline bool has_rcvbytespercentthreshold() const;
  inline void clear_rcvbytespercentthreshold();
  static const int kRcvbytespercentthresholdFieldNumber = 9;
  inline ::google::protobuf::uint64 rcvbytespercentthreshold() const;
  inline void set_rcvbytespercentthreshold(::google::protobuf::uint64 value);

  // optional uint64 rcvbuffersthreshold = 10;
  inline bool has_rcvbuffersthreshold() const;
  inline void clear_rcvbuffersthreshold();
  static const int kRcvbuffersthresholdFieldNumber = 10;
  inline ::google::protobuf::uint64 rcvbuffersthreshold() const;
  inline void set_rcvbuffersthreshold(::google::protobuf::uint64 value);

  // optional .rina.messages.policyDescriptor_t closedwindowpolicy = 11;
  inline bool has_closedwindowpolicy() const;
  inline void clear_closedwindowpolicy();
  static const int kClosedwindowpolicyFieldNumber = 11;
  inline const ::rina::messages::policyDescriptor_t& closedwindowpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_closedwindowpolicy();
  inline ::rina::messages::policyDescriptor_t* release_closedwindowpolicy();
  inline void set_allocated_closedwindowpolicy(::rina::messages::policyDescriptor_t* closedwindowpolicy);

  // optional .rina.messages.policyDescriptor_t flowcontroloverrunpolicy = 12;
  inline bool has_flowcontroloverrunpolicy() const;
  inline void clear_flowcontroloverrunpolicy();
  static const int kFlowcontroloverrunpolicyFieldNumber = 12;
  inline const ::rina::messages::policyDescriptor_t& flowcontroloverrunpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_flowcontroloverrunpolicy();
  inline ::rina::messages::policyDescriptor_t* release_flowcontroloverrunpolicy();
  inline void set_allocated_flowcontroloverrunpolicy(::rina::messages::policyDescriptor_t* flowcontroloverrunpolicy);

  // optional .rina.messages.policyDescriptor_t reconcileflowcontrolpolicy = 13;
  inline bool has_reconcileflowcontrolpolicy() const;
  inline void clear_reconcileflowcontrolpolicy();
  static const int kReconcileflowcontrolpolicyFieldNumber = 13;
  inline const ::rina::messages::policyDescriptor_t& reconcileflowcontrolpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_reconcileflowcontrolpolicy();
  inline ::rina::messages::policyDescriptor_t* release_reconcileflowcontrolpolicy();
  inline void set_allocated_reconcileflowcontrolpolicy(::rina::messages::policyDescriptor_t* reconcileflowcontrolpolicy);

  // optional .rina.messages.policyDescriptor_t receivingflowcontrolpolicy = 14;
  inline bool has_receivingflowcontrolpolicy() const;
  inline void clear_receivingflowcontrolpolicy();
  static const int kReceivingflowcontrolpolicyFieldNumber = 14;
  inline const ::rina::messages::policyDescriptor_t& receivingflowcontrolpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_receivingflowcontrolpolicy();
  inline ::rina::messages::policyDescriptor_t* release_receivingflowcontrolpolicy();
  inline void set_allocated_receivingflowcontrolpolicy(::rina::messages::policyDescriptor_t* receivingflowcontrolpolicy);

  // @@protoc_insertion_point(class_scope:rina.messages.dtcpFlowControlConfig_t)
 private:
  inline void set_has_windowbased();
  inline void clear_has_windowbased();
  inline void set_has_windowbasedconfig();
  inline void clear_has_windowbasedconfig();
  inline void set_has_ratebased();
  inline void clear_has_ratebased();
  inline void set_has_ratebasedconfig();
  inline void clear_has_ratebasedconfig();
  inline void set_has_sentbytesthreshold();
  inline void clear_has_sentbytesthreshold();
  inline void set_has_sentbytespercentthreshold();
  inline void clear_has_sentbytespercentthreshold();
  inline void set_has_sentbuffersthreshold();
  inline void clear_has_sentbuffersthreshold();
  inline void set_has_rcvbytesthreshold();
  inline void clear_has_rcvbytesthreshold();
  inline void set_has_rcvbytespercentthreshold();
  inline void clear_has_rcvbytespercentthreshold();
  inline void set_has_rcvbuffersthreshold();
  inline void clear_has_rcvbuffersthreshold();
  inline void set_has_closedwindowpolicy();
  inline void clear_has_closedwindowpolicy();
  inline void set_has_flowcontroloverrunpolicy();
  inline void clear_has_flowcontroloverrunpolicy();
  inline void set_has_reconcileflowcontrolpolicy();
  inline void clear_has_reconcileflowcontrolpolicy();
  inline void set_has_receivingflowcontrolpolicy();
  inline void clear_has_receivingflowcontrolpolicy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rina::messages::dtcpWindowBasedFlowControlConfig_t* windowbasedconfig_;
  ::rina::messages::dtcpRateBasedFlowControlConfig_t* ratebasedconfig_;
  ::google::protobuf::uint64 sentbytesthreshold_;
  ::google::protobuf::uint64 sentbytespercentthreshold_;
  ::google::protobuf::uint64 sentbuffersthreshold_;
  ::google::protobuf::uint64 rcvbytesthreshold_;
  ::google::protobuf::uint64 rcvbytespercentthreshold_;
  ::google::protobuf::uint64 rcvbuffersthreshold_;
  ::rina::messages::policyDescriptor_t* closedwindowpolicy_;
  ::rina::messages::policyDescriptor_t* flowcontroloverrunpolicy_;
  ::rina::messages::policyDescriptor_t* reconcileflowcontrolpolicy_;
  ::rina::messages::policyDescriptor_t* receivingflowcontrolpolicy_;
  bool windowbased_;
  bool ratebased_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_AssignDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_ShutdownFile_ConnectionPoliciesMessage_2eproto();

  void InitAsDefaultInstance();
  static dtcpFlowControlConfig_t* default_instance_;
};
// -------------------------------------------------------------------

class dtcpRtxControlConfig_t : public ::google::protobuf::Message {
 public:
  dtcpRtxControlConfig_t();
  virtual ~dtcpRtxControlConfig_t();

  dtcpRtxControlConfig_t(const dtcpRtxControlConfig_t& from);

  inline dtcpRtxControlConfig_t& operator=(const dtcpRtxControlConfig_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dtcpRtxControlConfig_t& default_instance();

  void Swap(dtcpRtxControlConfig_t* other);

  // implements Message ----------------------------------------------

  dtcpRtxControlConfig_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dtcpRtxControlConfig_t& from);
  void MergeFrom(const dtcpRtxControlConfig_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 datarxmsnmax = 1;
  inline bool has_datarxmsnmax() const;
  inline void clear_datarxmsnmax();
  static const int kDatarxmsnmaxFieldNumber = 1;
  inline ::google::protobuf::uint32 datarxmsnmax() const;
  inline void set_datarxmsnmax(::google::protobuf::uint32 value);

  // optional .rina.messages.policyDescriptor_t rtxtimerexpirypolicy = 2;
  inline bool has_rtxtimerexpirypolicy() const;
  inline void clear_rtxtimerexpirypolicy();
  static const int kRtxtimerexpirypolicyFieldNumber = 2;
  inline const ::rina::messages::policyDescriptor_t& rtxtimerexpirypolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_rtxtimerexpirypolicy();
  inline ::rina::messages::policyDescriptor_t* release_rtxtimerexpirypolicy();
  inline void set_allocated_rtxtimerexpirypolicy(::rina::messages::policyDescriptor_t* rtxtimerexpirypolicy);

  // optional .rina.messages.policyDescriptor_t senderackpolicy = 3;
  inline bool has_senderackpolicy() const;
  inline void clear_senderackpolicy();
  static const int kSenderackpolicyFieldNumber = 3;
  inline const ::rina::messages::policyDescriptor_t& senderackpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_senderackpolicy();
  inline ::rina::messages::policyDescriptor_t* release_senderackpolicy();
  inline void set_allocated_senderackpolicy(::rina::messages::policyDescriptor_t* senderackpolicy);

  // optional .rina.messages.policyDescriptor_t recvingacklistpolicy = 4;
  inline bool has_recvingacklistpolicy() const;
  inline void clear_recvingacklistpolicy();
  static const int kRecvingacklistpolicyFieldNumber = 4;
  inline const ::rina::messages::policyDescriptor_t& recvingacklistpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_recvingacklistpolicy();
  inline ::rina::messages::policyDescriptor_t* release_recvingacklistpolicy();
  inline void set_allocated_recvingacklistpolicy(::rina::messages::policyDescriptor_t* recvingacklistpolicy);

  // optional .rina.messages.policyDescriptor_t rcvrackpolicy = 5;
  inline bool has_rcvrackpolicy() const;
  inline void clear_rcvrackpolicy();
  static const int kRcvrackpolicyFieldNumber = 5;
  inline const ::rina::messages::policyDescriptor_t& rcvrackpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_rcvrackpolicy();
  inline ::rina::messages::policyDescriptor_t* release_rcvrackpolicy();
  inline void set_allocated_rcvrackpolicy(::rina::messages::policyDescriptor_t* rcvrackpolicy);

  // optional .rina.messages.policyDescriptor_t sendingackpolicy = 6;
  inline bool has_sendingackpolicy() const;
  inline void clear_sendingackpolicy();
  static const int kSendingackpolicyFieldNumber = 6;
  inline const ::rina::messages::policyDescriptor_t& sendingackpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_sendingackpolicy();
  inline ::rina::messages::policyDescriptor_t* release_sendingackpolicy();
  inline void set_allocated_sendingackpolicy(::rina::messages::policyDescriptor_t* sendingackpolicy);

  // optional .rina.messages.policyDescriptor_t rcvrcontrolackpolicy = 7;
  inline bool has_rcvrcontrolackpolicy() const;
  inline void clear_rcvrcontrolackpolicy();
  static const int kRcvrcontrolackpolicyFieldNumber = 7;
  inline const ::rina::messages::policyDescriptor_t& rcvrcontrolackpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_rcvrcontrolackpolicy();
  inline ::rina::messages::policyDescriptor_t* release_rcvrcontrolackpolicy();
  inline void set_allocated_rcvrcontrolackpolicy(::rina::messages::policyDescriptor_t* rcvrcontrolackpolicy);

  // @@protoc_insertion_point(class_scope:rina.messages.dtcpRtxControlConfig_t)
 private:
  inline void set_has_datarxmsnmax();
  inline void clear_has_datarxmsnmax();
  inline void set_has_rtxtimerexpirypolicy();
  inline void clear_has_rtxtimerexpirypolicy();
  inline void set_has_senderackpolicy();
  inline void clear_has_senderackpolicy();
  inline void set_has_recvingacklistpolicy();
  inline void clear_has_recvingacklistpolicy();
  inline void set_has_rcvrackpolicy();
  inline void clear_has_rcvrackpolicy();
  inline void set_has_sendingackpolicy();
  inline void clear_has_sendingackpolicy();
  inline void set_has_rcvrcontrolackpolicy();
  inline void clear_has_rcvrcontrolackpolicy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rina::messages::policyDescriptor_t* rtxtimerexpirypolicy_;
  ::rina::messages::policyDescriptor_t* senderackpolicy_;
  ::rina::messages::policyDescriptor_t* recvingacklistpolicy_;
  ::rina::messages::policyDescriptor_t* rcvrackpolicy_;
  ::rina::messages::policyDescriptor_t* sendingackpolicy_;
  ::rina::messages::policyDescriptor_t* rcvrcontrolackpolicy_;
  ::google::protobuf::uint32 datarxmsnmax_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_AssignDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_ShutdownFile_ConnectionPoliciesMessage_2eproto();

  void InitAsDefaultInstance();
  static dtcpRtxControlConfig_t* default_instance_;
};
// -------------------------------------------------------------------

class dtcpConfig_t : public ::google::protobuf::Message {
 public:
  dtcpConfig_t();
  virtual ~dtcpConfig_t();

  dtcpConfig_t(const dtcpConfig_t& from);

  inline dtcpConfig_t& operator=(const dtcpConfig_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dtcpConfig_t& default_instance();

  void Swap(dtcpConfig_t* other);

  // implements Message ----------------------------------------------

  dtcpConfig_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const dtcpConfig_t& from);
  void MergeFrom(const dtcpConfig_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool flowControl = 1;
  inline bool has_flowcontrol() const;
  inline void clear_flowcontrol();
  static const int kFlowControlFieldNumber = 1;
  inline bool flowcontrol() const;
  inline void set_flowcontrol(bool value);

  // optional .rina.messages.dtcpFlowControlConfig_t flowControlConfig = 2;
  inline bool has_flowcontrolconfig() const;
  inline void clear_flowcontrolconfig();
  static const int kFlowControlConfigFieldNumber = 2;
  inline const ::rina::messages::dtcpFlowControlConfig_t& flowcontrolconfig() const;
  inline ::rina::messages::dtcpFlowControlConfig_t* mutable_flowcontrolconfig();
  inline ::rina::messages::dtcpFlowControlConfig_t* release_flowcontrolconfig();
  inline void set_allocated_flowcontrolconfig(::rina::messages::dtcpFlowControlConfig_t* flowcontrolconfig);

  // optional bool rtxControl = 3;
  inline bool has_rtxcontrol() const;
  inline void clear_rtxcontrol();
  static const int kRtxControlFieldNumber = 3;
  inline bool rtxcontrol() const;
  inline void set_rtxcontrol(bool value);

  // optional .rina.messages.dtcpRtxControlConfig_t rtxControlConfig = 4;
  inline bool has_rtxcontrolconfig() const;
  inline void clear_rtxcontrolconfig();
  static const int kRtxControlConfigFieldNumber = 4;
  inline const ::rina::messages::dtcpRtxControlConfig_t& rtxcontrolconfig() const;
  inline ::rina::messages::dtcpRtxControlConfig_t* mutable_rtxcontrolconfig();
  inline ::rina::messages::dtcpRtxControlConfig_t* release_rtxcontrolconfig();
  inline void set_allocated_rtxcontrolconfig(::rina::messages::dtcpRtxControlConfig_t* rtxcontrolconfig);

  // optional uint32 initialsenderinactivitytime = 5;
  inline bool has_initialsenderinactivitytime() const;
  inline void clear_initialsenderinactivitytime();
  static const int kInitialsenderinactivitytimeFieldNumber = 5;
  inline ::google::protobuf::uint32 initialsenderinactivitytime() const;
  inline void set_initialsenderinactivitytime(::google::protobuf::uint32 value);

  // optional uint32 initialrecvrinactivitytime = 6;
  inline bool has_initialrecvrinactivitytime() const;
  inline void clear_initialrecvrinactivitytime();
  static const int kInitialrecvrinactivitytimeFieldNumber = 6;
  inline ::google::protobuf::uint32 initialrecvrinactivitytime() const;
  inline void set_initialrecvrinactivitytime(::google::protobuf::uint32 value);

  // optional .rina.messages.policyDescriptor_t rcvrtimerinactivitypolicy = 7;
  inline bool has_rcvrtimerinactivitypolicy() const;
  inline void clear_rcvrtimerinactivitypolicy();
  static const int kRcvrtimerinactivitypolicyFieldNumber = 7;
  inline const ::rina::messages::policyDescriptor_t& rcvrtimerinactivitypolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_rcvrtimerinactivitypolicy();
  inline ::rina::messages::policyDescriptor_t* release_rcvrtimerinactivitypolicy();
  inline void set_allocated_rcvrtimerinactivitypolicy(::rina::messages::policyDescriptor_t* rcvrtimerinactivitypolicy);

  // optional .rina.messages.policyDescriptor_t sendertimerinactiviypolicy = 8;
  inline bool has_sendertimerinactiviypolicy() const;
  inline void clear_sendertimerinactiviypolicy();
  static const int kSendertimerinactiviypolicyFieldNumber = 8;
  inline const ::rina::messages::policyDescriptor_t& sendertimerinactiviypolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_sendertimerinactiviypolicy();
  inline ::rina::messages::policyDescriptor_t* release_sendertimerinactiviypolicy();
  inline void set_allocated_sendertimerinactiviypolicy(::rina::messages::policyDescriptor_t* sendertimerinactiviypolicy);

  // optional .rina.messages.policyDescriptor_t lostcontrolpdupolicy = 9;
  inline bool has_lostcontrolpdupolicy() const;
  inline void clear_lostcontrolpdupolicy();
  static const int kLostcontrolpdupolicyFieldNumber = 9;
  inline const ::rina::messages::policyDescriptor_t& lostcontrolpdupolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_lostcontrolpdupolicy();
  inline ::rina::messages::policyDescriptor_t* release_lostcontrolpdupolicy();
  inline void set_allocated_lostcontrolpdupolicy(::rina::messages::policyDescriptor_t* lostcontrolpdupolicy);

  // optional .rina.messages.policyDescriptor_t rttestimatorpolicy = 10;
  inline bool has_rttestimatorpolicy() const;
  inline void clear_rttestimatorpolicy();
  static const int kRttestimatorpolicyFieldNumber = 10;
  inline const ::rina::messages::policyDescriptor_t& rttestimatorpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_rttestimatorpolicy();
  inline ::rina::messages::policyDescriptor_t* release_rttestimatorpolicy();
  inline void set_allocated_rttestimatorpolicy(::rina::messages::policyDescriptor_t* rttestimatorpolicy);

  // @@protoc_insertion_point(class_scope:rina.messages.dtcpConfig_t)
 private:
  inline void set_has_flowcontrol();
  inline void clear_has_flowcontrol();
  inline void set_has_flowcontrolconfig();
  inline void clear_has_flowcontrolconfig();
  inline void set_has_rtxcontrol();
  inline void clear_has_rtxcontrol();
  inline void set_has_rtxcontrolconfig();
  inline void clear_has_rtxcontrolconfig();
  inline void set_has_initialsenderinactivitytime();
  inline void clear_has_initialsenderinactivitytime();
  inline void set_has_initialrecvrinactivitytime();
  inline void clear_has_initialrecvrinactivitytime();
  inline void set_has_rcvrtimerinactivitypolicy();
  inline void clear_has_rcvrtimerinactivitypolicy();
  inline void set_has_sendertimerinactiviypolicy();
  inline void clear_has_sendertimerinactiviypolicy();
  inline void set_has_lostcontrolpdupolicy();
  inline void clear_has_lostcontrolpdupolicy();
  inline void set_has_rttestimatorpolicy();
  inline void clear_has_rttestimatorpolicy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rina::messages::dtcpFlowControlConfig_t* flowcontrolconfig_;
  bool flowcontrol_;
  bool rtxcontrol_;
  ::google::protobuf::uint32 initialsenderinactivitytime_;
  ::rina::messages::dtcpRtxControlConfig_t* rtxcontrolconfig_;
  ::rina::messages::policyDescriptor_t* rcvrtimerinactivitypolicy_;
  ::rina::messages::policyDescriptor_t* sendertimerinactiviypolicy_;
  ::rina::messages::policyDescriptor_t* lostcontrolpdupolicy_;
  ::rina::messages::policyDescriptor_t* rttestimatorpolicy_;
  ::google::protobuf::uint32 initialrecvrinactivitytime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_AssignDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_ShutdownFile_ConnectionPoliciesMessage_2eproto();

  void InitAsDefaultInstance();
  static dtcpConfig_t* default_instance_;
};
// -------------------------------------------------------------------

class connectionPolicies_t : public ::google::protobuf::Message {
 public:
  connectionPolicies_t();
  virtual ~connectionPolicies_t();

  connectionPolicies_t(const connectionPolicies_t& from);

  inline connectionPolicies_t& operator=(const connectionPolicies_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connectionPolicies_t& default_instance();

  void Swap(connectionPolicies_t* other);

  // implements Message ----------------------------------------------

  connectionPolicies_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const connectionPolicies_t& from);
  void MergeFrom(const connectionPolicies_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool dtcpPresent = 1;
  inline bool has_dtcppresent() const;
  inline void clear_dtcppresent();
  static const int kDtcpPresentFieldNumber = 1;
  inline bool dtcppresent() const;
  inline void set_dtcppresent(bool value);

  // optional .rina.messages.dtcpConfig_t dtcpConfiguration = 2;
  inline bool has_dtcpconfiguration() const;
  inline void clear_dtcpconfiguration();
  static const int kDtcpConfigurationFieldNumber = 2;
  inline const ::rina::messages::dtcpConfig_t& dtcpconfiguration() const;
  inline ::rina::messages::dtcpConfig_t* mutable_dtcpconfiguration();
  inline ::rina::messages::dtcpConfig_t* release_dtcpconfiguration();
  inline void set_allocated_dtcpconfiguration(::rina::messages::dtcpConfig_t* dtcpconfiguration);

  // optional .rina.messages.policyDescriptor_t initialseqnumpolicy = 3;
  inline bool has_initialseqnumpolicy() const;
  inline void clear_initialseqnumpolicy();
  static const int kInitialseqnumpolicyFieldNumber = 3;
  inline const ::rina::messages::policyDescriptor_t& initialseqnumpolicy() const;
  inline ::rina::messages::policyDescriptor_t* mutable_initialseqnumpolicy();
  inline ::rina::messages::policyDescriptor_t* release_initialseqnumpolicy();
  inline void set_allocated_initialseqnumpolicy(::rina::messages::policyDescriptor_t* initialseqnumpolicy);

  // optional uint64 seqnumrolloverthreshold = 4;
  inline bool has_seqnumrolloverthreshold() const;
  inline void clear_seqnumrolloverthreshold();
  static const int kSeqnumrolloverthresholdFieldNumber = 4;
  inline ::google::protobuf::uint64 seqnumrolloverthreshold() const;
  inline void set_seqnumrolloverthreshold(::google::protobuf::uint64 value);

  // optional uint32 initialATimer = 5;
  inline bool has_initialatimer() const;
  inline void clear_initialatimer();
  static const int kInitialATimerFieldNumber = 5;
  inline ::google::protobuf::uint32 initialatimer() const;
  inline void set_initialatimer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rina.messages.connectionPolicies_t)
 private:
  inline void set_has_dtcppresent();
  inline void clear_has_dtcppresent();
  inline void set_has_dtcpconfiguration();
  inline void clear_has_dtcpconfiguration();
  inline void set_has_initialseqnumpolicy();
  inline void clear_has_initialseqnumpolicy();
  inline void set_has_seqnumrolloverthreshold();
  inline void clear_has_seqnumrolloverthreshold();
  inline void set_has_initialatimer();
  inline void clear_has_initialatimer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rina::messages::dtcpConfig_t* dtcpconfiguration_;
  ::rina::messages::policyDescriptor_t* initialseqnumpolicy_;
  bool dtcppresent_;
  ::google::protobuf::uint32 initialatimer_;
  ::google::protobuf::uint64 seqnumrolloverthreshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_AssignDesc_ConnectionPoliciesMessage_2eproto();
  friend void protobuf_ShutdownFile_ConnectionPoliciesMessage_2eproto();

  void InitAsDefaultInstance();
  static connectionPolicies_t* default_instance_;
};
// ===================================================================


// ===================================================================

// dtcpWindowBasedFlowControlConfig_t

// optional uint64 maxclosedwindowqueuelength = 1;
inline bool dtcpWindowBasedFlowControlConfig_t::has_maxclosedwindowqueuelength() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dtcpWindowBasedFlowControlConfig_t::set_has_maxclosedwindowqueuelength() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dtcpWindowBasedFlowControlConfig_t::clear_has_maxclosedwindowqueuelength() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dtcpWindowBasedFlowControlConfig_t::clear_maxclosedwindowqueuelength() {
  maxclosedwindowqueuelength_ = GOOGLE_ULONGLONG(0);
  clear_has_maxclosedwindowqueuelength();
}
inline ::google::protobuf::uint64 dtcpWindowBasedFlowControlConfig_t::maxclosedwindowqueuelength() const {
  return maxclosedwindowqueuelength_;
}
inline void dtcpWindowBasedFlowControlConfig_t::set_maxclosedwindowqueuelength(::google::protobuf::uint64 value) {
  set_has_maxclosedwindowqueuelength();
  maxclosedwindowqueuelength_ = value;
}

// optional uint64 initialcredit = 2;
inline bool dtcpWindowBasedFlowControlConfig_t::has_initialcredit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dtcpWindowBasedFlowControlConfig_t::set_has_initialcredit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dtcpWindowBasedFlowControlConfig_t::clear_has_initialcredit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dtcpWindowBasedFlowControlConfig_t::clear_initialcredit() {
  initialcredit_ = GOOGLE_ULONGLONG(0);
  clear_has_initialcredit();
}
inline ::google::protobuf::uint64 dtcpWindowBasedFlowControlConfig_t::initialcredit() const {
  return initialcredit_;
}
inline void dtcpWindowBasedFlowControlConfig_t::set_initialcredit(::google::protobuf::uint64 value) {
  set_has_initialcredit();
  initialcredit_ = value;
}

// optional .rina.messages.policyDescriptor_t rcvrflowcontrolpolicy = 3;
inline bool dtcpWindowBasedFlowControlConfig_t::has_rcvrflowcontrolpolicy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dtcpWindowBasedFlowControlConfig_t::set_has_rcvrflowcontrolpolicy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dtcpWindowBasedFlowControlConfig_t::clear_has_rcvrflowcontrolpolicy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dtcpWindowBasedFlowControlConfig_t::clear_rcvrflowcontrolpolicy() {
  if (rcvrflowcontrolpolicy_ != NULL) rcvrflowcontrolpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_rcvrflowcontrolpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpWindowBasedFlowControlConfig_t::rcvrflowcontrolpolicy() const {
  return rcvrflowcontrolpolicy_ != NULL ? *rcvrflowcontrolpolicy_ : *default_instance_->rcvrflowcontrolpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpWindowBasedFlowControlConfig_t::mutable_rcvrflowcontrolpolicy() {
  set_has_rcvrflowcontrolpolicy();
  if (rcvrflowcontrolpolicy_ == NULL) rcvrflowcontrolpolicy_ = new ::rina::messages::policyDescriptor_t;
  return rcvrflowcontrolpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpWindowBasedFlowControlConfig_t::release_rcvrflowcontrolpolicy() {
  clear_has_rcvrflowcontrolpolicy();
  ::rina::messages::policyDescriptor_t* temp = rcvrflowcontrolpolicy_;
  rcvrflowcontrolpolicy_ = NULL;
  return temp;
}
inline void dtcpWindowBasedFlowControlConfig_t::set_allocated_rcvrflowcontrolpolicy(::rina::messages::policyDescriptor_t* rcvrflowcontrolpolicy) {
  delete rcvrflowcontrolpolicy_;
  rcvrflowcontrolpolicy_ = rcvrflowcontrolpolicy;
  if (rcvrflowcontrolpolicy) {
    set_has_rcvrflowcontrolpolicy();
  } else {
    clear_has_rcvrflowcontrolpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t txcontrolpolicy = 4;
inline bool dtcpWindowBasedFlowControlConfig_t::has_txcontrolpolicy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dtcpWindowBasedFlowControlConfig_t::set_has_txcontrolpolicy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dtcpWindowBasedFlowControlConfig_t::clear_has_txcontrolpolicy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dtcpWindowBasedFlowControlConfig_t::clear_txcontrolpolicy() {
  if (txcontrolpolicy_ != NULL) txcontrolpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_txcontrolpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpWindowBasedFlowControlConfig_t::txcontrolpolicy() const {
  return txcontrolpolicy_ != NULL ? *txcontrolpolicy_ : *default_instance_->txcontrolpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpWindowBasedFlowControlConfig_t::mutable_txcontrolpolicy() {
  set_has_txcontrolpolicy();
  if (txcontrolpolicy_ == NULL) txcontrolpolicy_ = new ::rina::messages::policyDescriptor_t;
  return txcontrolpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpWindowBasedFlowControlConfig_t::release_txcontrolpolicy() {
  clear_has_txcontrolpolicy();
  ::rina::messages::policyDescriptor_t* temp = txcontrolpolicy_;
  txcontrolpolicy_ = NULL;
  return temp;
}
inline void dtcpWindowBasedFlowControlConfig_t::set_allocated_txcontrolpolicy(::rina::messages::policyDescriptor_t* txcontrolpolicy) {
  delete txcontrolpolicy_;
  txcontrolpolicy_ = txcontrolpolicy;
  if (txcontrolpolicy) {
    set_has_txcontrolpolicy();
  } else {
    clear_has_txcontrolpolicy();
  }
}

// -------------------------------------------------------------------

// dtcpRateBasedFlowControlConfig_t

// optional uint64 sendingrate = 1;
inline bool dtcpRateBasedFlowControlConfig_t::has_sendingrate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dtcpRateBasedFlowControlConfig_t::set_has_sendingrate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_has_sendingrate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_sendingrate() {
  sendingrate_ = GOOGLE_ULONGLONG(0);
  clear_has_sendingrate();
}
inline ::google::protobuf::uint64 dtcpRateBasedFlowControlConfig_t::sendingrate() const {
  return sendingrate_;
}
inline void dtcpRateBasedFlowControlConfig_t::set_sendingrate(::google::protobuf::uint64 value) {
  set_has_sendingrate();
  sendingrate_ = value;
}

// optional uint64 timeperiod = 2;
inline bool dtcpRateBasedFlowControlConfig_t::has_timeperiod() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dtcpRateBasedFlowControlConfig_t::set_has_timeperiod() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_has_timeperiod() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_timeperiod() {
  timeperiod_ = GOOGLE_ULONGLONG(0);
  clear_has_timeperiod();
}
inline ::google::protobuf::uint64 dtcpRateBasedFlowControlConfig_t::timeperiod() const {
  return timeperiod_;
}
inline void dtcpRateBasedFlowControlConfig_t::set_timeperiod(::google::protobuf::uint64 value) {
  set_has_timeperiod();
  timeperiod_ = value;
}

// optional .rina.messages.policyDescriptor_t norateslowdownpolicy = 3;
inline bool dtcpRateBasedFlowControlConfig_t::has_norateslowdownpolicy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dtcpRateBasedFlowControlConfig_t::set_has_norateslowdownpolicy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_has_norateslowdownpolicy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_norateslowdownpolicy() {
  if (norateslowdownpolicy_ != NULL) norateslowdownpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_norateslowdownpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRateBasedFlowControlConfig_t::norateslowdownpolicy() const {
  return norateslowdownpolicy_ != NULL ? *norateslowdownpolicy_ : *default_instance_->norateslowdownpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRateBasedFlowControlConfig_t::mutable_norateslowdownpolicy() {
  set_has_norateslowdownpolicy();
  if (norateslowdownpolicy_ == NULL) norateslowdownpolicy_ = new ::rina::messages::policyDescriptor_t;
  return norateslowdownpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRateBasedFlowControlConfig_t::release_norateslowdownpolicy() {
  clear_has_norateslowdownpolicy();
  ::rina::messages::policyDescriptor_t* temp = norateslowdownpolicy_;
  norateslowdownpolicy_ = NULL;
  return temp;
}
inline void dtcpRateBasedFlowControlConfig_t::set_allocated_norateslowdownpolicy(::rina::messages::policyDescriptor_t* norateslowdownpolicy) {
  delete norateslowdownpolicy_;
  norateslowdownpolicy_ = norateslowdownpolicy;
  if (norateslowdownpolicy) {
    set_has_norateslowdownpolicy();
  } else {
    clear_has_norateslowdownpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t nooverridedefaultpeakpolicy = 4;
inline bool dtcpRateBasedFlowControlConfig_t::has_nooverridedefaultpeakpolicy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dtcpRateBasedFlowControlConfig_t::set_has_nooverridedefaultpeakpolicy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_has_nooverridedefaultpeakpolicy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_nooverridedefaultpeakpolicy() {
  if (nooverridedefaultpeakpolicy_ != NULL) nooverridedefaultpeakpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_nooverridedefaultpeakpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRateBasedFlowControlConfig_t::nooverridedefaultpeakpolicy() const {
  return nooverridedefaultpeakpolicy_ != NULL ? *nooverridedefaultpeakpolicy_ : *default_instance_->nooverridedefaultpeakpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRateBasedFlowControlConfig_t::mutable_nooverridedefaultpeakpolicy() {
  set_has_nooverridedefaultpeakpolicy();
  if (nooverridedefaultpeakpolicy_ == NULL) nooverridedefaultpeakpolicy_ = new ::rina::messages::policyDescriptor_t;
  return nooverridedefaultpeakpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRateBasedFlowControlConfig_t::release_nooverridedefaultpeakpolicy() {
  clear_has_nooverridedefaultpeakpolicy();
  ::rina::messages::policyDescriptor_t* temp = nooverridedefaultpeakpolicy_;
  nooverridedefaultpeakpolicy_ = NULL;
  return temp;
}
inline void dtcpRateBasedFlowControlConfig_t::set_allocated_nooverridedefaultpeakpolicy(::rina::messages::policyDescriptor_t* nooverridedefaultpeakpolicy) {
  delete nooverridedefaultpeakpolicy_;
  nooverridedefaultpeakpolicy_ = nooverridedefaultpeakpolicy;
  if (nooverridedefaultpeakpolicy) {
    set_has_nooverridedefaultpeakpolicy();
  } else {
    clear_has_nooverridedefaultpeakpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t ratereductionpolicy = 5;
inline bool dtcpRateBasedFlowControlConfig_t::has_ratereductionpolicy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dtcpRateBasedFlowControlConfig_t::set_has_ratereductionpolicy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_has_ratereductionpolicy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dtcpRateBasedFlowControlConfig_t::clear_ratereductionpolicy() {
  if (ratereductionpolicy_ != NULL) ratereductionpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_ratereductionpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRateBasedFlowControlConfig_t::ratereductionpolicy() const {
  return ratereductionpolicy_ != NULL ? *ratereductionpolicy_ : *default_instance_->ratereductionpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRateBasedFlowControlConfig_t::mutable_ratereductionpolicy() {
  set_has_ratereductionpolicy();
  if (ratereductionpolicy_ == NULL) ratereductionpolicy_ = new ::rina::messages::policyDescriptor_t;
  return ratereductionpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRateBasedFlowControlConfig_t::release_ratereductionpolicy() {
  clear_has_ratereductionpolicy();
  ::rina::messages::policyDescriptor_t* temp = ratereductionpolicy_;
  ratereductionpolicy_ = NULL;
  return temp;
}
inline void dtcpRateBasedFlowControlConfig_t::set_allocated_ratereductionpolicy(::rina::messages::policyDescriptor_t* ratereductionpolicy) {
  delete ratereductionpolicy_;
  ratereductionpolicy_ = ratereductionpolicy;
  if (ratereductionpolicy) {
    set_has_ratereductionpolicy();
  } else {
    clear_has_ratereductionpolicy();
  }
}

// -------------------------------------------------------------------

// dtcpFlowControlConfig_t

// optional bool windowBased = 1;
inline bool dtcpFlowControlConfig_t::has_windowbased() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_windowbased() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dtcpFlowControlConfig_t::clear_has_windowbased() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dtcpFlowControlConfig_t::clear_windowbased() {
  windowbased_ = false;
  clear_has_windowbased();
}
inline bool dtcpFlowControlConfig_t::windowbased() const {
  return windowbased_;
}
inline void dtcpFlowControlConfig_t::set_windowbased(bool value) {
  set_has_windowbased();
  windowbased_ = value;
}

// optional .rina.messages.dtcpWindowBasedFlowControlConfig_t windowBasedConfig = 2;
inline bool dtcpFlowControlConfig_t::has_windowbasedconfig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_windowbasedconfig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dtcpFlowControlConfig_t::clear_has_windowbasedconfig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dtcpFlowControlConfig_t::clear_windowbasedconfig() {
  if (windowbasedconfig_ != NULL) windowbasedconfig_->::rina::messages::dtcpWindowBasedFlowControlConfig_t::Clear();
  clear_has_windowbasedconfig();
}
inline const ::rina::messages::dtcpWindowBasedFlowControlConfig_t& dtcpFlowControlConfig_t::windowbasedconfig() const {
  return windowbasedconfig_ != NULL ? *windowbasedconfig_ : *default_instance_->windowbasedconfig_;
}
inline ::rina::messages::dtcpWindowBasedFlowControlConfig_t* dtcpFlowControlConfig_t::mutable_windowbasedconfig() {
  set_has_windowbasedconfig();
  if (windowbasedconfig_ == NULL) windowbasedconfig_ = new ::rina::messages::dtcpWindowBasedFlowControlConfig_t;
  return windowbasedconfig_;
}
inline ::rina::messages::dtcpWindowBasedFlowControlConfig_t* dtcpFlowControlConfig_t::release_windowbasedconfig() {
  clear_has_windowbasedconfig();
  ::rina::messages::dtcpWindowBasedFlowControlConfig_t* temp = windowbasedconfig_;
  windowbasedconfig_ = NULL;
  return temp;
}
inline void dtcpFlowControlConfig_t::set_allocated_windowbasedconfig(::rina::messages::dtcpWindowBasedFlowControlConfig_t* windowbasedconfig) {
  delete windowbasedconfig_;
  windowbasedconfig_ = windowbasedconfig;
  if (windowbasedconfig) {
    set_has_windowbasedconfig();
  } else {
    clear_has_windowbasedconfig();
  }
}

// optional bool rateBased = 3;
inline bool dtcpFlowControlConfig_t::has_ratebased() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_ratebased() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dtcpFlowControlConfig_t::clear_has_ratebased() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dtcpFlowControlConfig_t::clear_ratebased() {
  ratebased_ = false;
  clear_has_ratebased();
}
inline bool dtcpFlowControlConfig_t::ratebased() const {
  return ratebased_;
}
inline void dtcpFlowControlConfig_t::set_ratebased(bool value) {
  set_has_ratebased();
  ratebased_ = value;
}

// optional .rina.messages.dtcpRateBasedFlowControlConfig_t rateBasedConfig = 4;
inline bool dtcpFlowControlConfig_t::has_ratebasedconfig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_ratebasedconfig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dtcpFlowControlConfig_t::clear_has_ratebasedconfig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dtcpFlowControlConfig_t::clear_ratebasedconfig() {
  if (ratebasedconfig_ != NULL) ratebasedconfig_->::rina::messages::dtcpRateBasedFlowControlConfig_t::Clear();
  clear_has_ratebasedconfig();
}
inline const ::rina::messages::dtcpRateBasedFlowControlConfig_t& dtcpFlowControlConfig_t::ratebasedconfig() const {
  return ratebasedconfig_ != NULL ? *ratebasedconfig_ : *default_instance_->ratebasedconfig_;
}
inline ::rina::messages::dtcpRateBasedFlowControlConfig_t* dtcpFlowControlConfig_t::mutable_ratebasedconfig() {
  set_has_ratebasedconfig();
  if (ratebasedconfig_ == NULL) ratebasedconfig_ = new ::rina::messages::dtcpRateBasedFlowControlConfig_t;
  return ratebasedconfig_;
}
inline ::rina::messages::dtcpRateBasedFlowControlConfig_t* dtcpFlowControlConfig_t::release_ratebasedconfig() {
  clear_has_ratebasedconfig();
  ::rina::messages::dtcpRateBasedFlowControlConfig_t* temp = ratebasedconfig_;
  ratebasedconfig_ = NULL;
  return temp;
}
inline void dtcpFlowControlConfig_t::set_allocated_ratebasedconfig(::rina::messages::dtcpRateBasedFlowControlConfig_t* ratebasedconfig) {
  delete ratebasedconfig_;
  ratebasedconfig_ = ratebasedconfig;
  if (ratebasedconfig) {
    set_has_ratebasedconfig();
  } else {
    clear_has_ratebasedconfig();
  }
}

// optional uint64 sentbytesthreshold = 5;
inline bool dtcpFlowControlConfig_t::has_sentbytesthreshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_sentbytesthreshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dtcpFlowControlConfig_t::clear_has_sentbytesthreshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dtcpFlowControlConfig_t::clear_sentbytesthreshold() {
  sentbytesthreshold_ = GOOGLE_ULONGLONG(0);
  clear_has_sentbytesthreshold();
}
inline ::google::protobuf::uint64 dtcpFlowControlConfig_t::sentbytesthreshold() const {
  return sentbytesthreshold_;
}
inline void dtcpFlowControlConfig_t::set_sentbytesthreshold(::google::protobuf::uint64 value) {
  set_has_sentbytesthreshold();
  sentbytesthreshold_ = value;
}

// optional uint64 sentbytespercentthreshold = 6;
inline bool dtcpFlowControlConfig_t::has_sentbytespercentthreshold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_sentbytespercentthreshold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dtcpFlowControlConfig_t::clear_has_sentbytespercentthreshold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dtcpFlowControlConfig_t::clear_sentbytespercentthreshold() {
  sentbytespercentthreshold_ = GOOGLE_ULONGLONG(0);
  clear_has_sentbytespercentthreshold();
}
inline ::google::protobuf::uint64 dtcpFlowControlConfig_t::sentbytespercentthreshold() const {
  return sentbytespercentthreshold_;
}
inline void dtcpFlowControlConfig_t::set_sentbytespercentthreshold(::google::protobuf::uint64 value) {
  set_has_sentbytespercentthreshold();
  sentbytespercentthreshold_ = value;
}

// optional uint64 sentbuffersthreshold = 7;
inline bool dtcpFlowControlConfig_t::has_sentbuffersthreshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_sentbuffersthreshold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dtcpFlowControlConfig_t::clear_has_sentbuffersthreshold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dtcpFlowControlConfig_t::clear_sentbuffersthreshold() {
  sentbuffersthreshold_ = GOOGLE_ULONGLONG(0);
  clear_has_sentbuffersthreshold();
}
inline ::google::protobuf::uint64 dtcpFlowControlConfig_t::sentbuffersthreshold() const {
  return sentbuffersthreshold_;
}
inline void dtcpFlowControlConfig_t::set_sentbuffersthreshold(::google::protobuf::uint64 value) {
  set_has_sentbuffersthreshold();
  sentbuffersthreshold_ = value;
}

// optional uint64 rcvbytesthreshold = 8;
inline bool dtcpFlowControlConfig_t::has_rcvbytesthreshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_rcvbytesthreshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void dtcpFlowControlConfig_t::clear_has_rcvbytesthreshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void dtcpFlowControlConfig_t::clear_rcvbytesthreshold() {
  rcvbytesthreshold_ = GOOGLE_ULONGLONG(0);
  clear_has_rcvbytesthreshold();
}
inline ::google::protobuf::uint64 dtcpFlowControlConfig_t::rcvbytesthreshold() const {
  return rcvbytesthreshold_;
}
inline void dtcpFlowControlConfig_t::set_rcvbytesthreshold(::google::protobuf::uint64 value) {
  set_has_rcvbytesthreshold();
  rcvbytesthreshold_ = value;
}

// optional uint64 rcvbytespercentthreshold = 9;
inline bool dtcpFlowControlConfig_t::has_rcvbytespercentthreshold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_rcvbytespercentthreshold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void dtcpFlowControlConfig_t::clear_has_rcvbytespercentthreshold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void dtcpFlowControlConfig_t::clear_rcvbytespercentthreshold() {
  rcvbytespercentthreshold_ = GOOGLE_ULONGLONG(0);
  clear_has_rcvbytespercentthreshold();
}
inline ::google::protobuf::uint64 dtcpFlowControlConfig_t::rcvbytespercentthreshold() const {
  return rcvbytespercentthreshold_;
}
inline void dtcpFlowControlConfig_t::set_rcvbytespercentthreshold(::google::protobuf::uint64 value) {
  set_has_rcvbytespercentthreshold();
  rcvbytespercentthreshold_ = value;
}

// optional uint64 rcvbuffersthreshold = 10;
inline bool dtcpFlowControlConfig_t::has_rcvbuffersthreshold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_rcvbuffersthreshold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void dtcpFlowControlConfig_t::clear_has_rcvbuffersthreshold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void dtcpFlowControlConfig_t::clear_rcvbuffersthreshold() {
  rcvbuffersthreshold_ = GOOGLE_ULONGLONG(0);
  clear_has_rcvbuffersthreshold();
}
inline ::google::protobuf::uint64 dtcpFlowControlConfig_t::rcvbuffersthreshold() const {
  return rcvbuffersthreshold_;
}
inline void dtcpFlowControlConfig_t::set_rcvbuffersthreshold(::google::protobuf::uint64 value) {
  set_has_rcvbuffersthreshold();
  rcvbuffersthreshold_ = value;
}

// optional .rina.messages.policyDescriptor_t closedwindowpolicy = 11;
inline bool dtcpFlowControlConfig_t::has_closedwindowpolicy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_closedwindowpolicy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void dtcpFlowControlConfig_t::clear_has_closedwindowpolicy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void dtcpFlowControlConfig_t::clear_closedwindowpolicy() {
  if (closedwindowpolicy_ != NULL) closedwindowpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_closedwindowpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpFlowControlConfig_t::closedwindowpolicy() const {
  return closedwindowpolicy_ != NULL ? *closedwindowpolicy_ : *default_instance_->closedwindowpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpFlowControlConfig_t::mutable_closedwindowpolicy() {
  set_has_closedwindowpolicy();
  if (closedwindowpolicy_ == NULL) closedwindowpolicy_ = new ::rina::messages::policyDescriptor_t;
  return closedwindowpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpFlowControlConfig_t::release_closedwindowpolicy() {
  clear_has_closedwindowpolicy();
  ::rina::messages::policyDescriptor_t* temp = closedwindowpolicy_;
  closedwindowpolicy_ = NULL;
  return temp;
}
inline void dtcpFlowControlConfig_t::set_allocated_closedwindowpolicy(::rina::messages::policyDescriptor_t* closedwindowpolicy) {
  delete closedwindowpolicy_;
  closedwindowpolicy_ = closedwindowpolicy;
  if (closedwindowpolicy) {
    set_has_closedwindowpolicy();
  } else {
    clear_has_closedwindowpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t flowcontroloverrunpolicy = 12;
inline bool dtcpFlowControlConfig_t::has_flowcontroloverrunpolicy() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_flowcontroloverrunpolicy() {
  _has_bits_[0] |= 0x00000800u;
}
inline void dtcpFlowControlConfig_t::clear_has_flowcontroloverrunpolicy() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void dtcpFlowControlConfig_t::clear_flowcontroloverrunpolicy() {
  if (flowcontroloverrunpolicy_ != NULL) flowcontroloverrunpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_flowcontroloverrunpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpFlowControlConfig_t::flowcontroloverrunpolicy() const {
  return flowcontroloverrunpolicy_ != NULL ? *flowcontroloverrunpolicy_ : *default_instance_->flowcontroloverrunpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpFlowControlConfig_t::mutable_flowcontroloverrunpolicy() {
  set_has_flowcontroloverrunpolicy();
  if (flowcontroloverrunpolicy_ == NULL) flowcontroloverrunpolicy_ = new ::rina::messages::policyDescriptor_t;
  return flowcontroloverrunpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpFlowControlConfig_t::release_flowcontroloverrunpolicy() {
  clear_has_flowcontroloverrunpolicy();
  ::rina::messages::policyDescriptor_t* temp = flowcontroloverrunpolicy_;
  flowcontroloverrunpolicy_ = NULL;
  return temp;
}
inline void dtcpFlowControlConfig_t::set_allocated_flowcontroloverrunpolicy(::rina::messages::policyDescriptor_t* flowcontroloverrunpolicy) {
  delete flowcontroloverrunpolicy_;
  flowcontroloverrunpolicy_ = flowcontroloverrunpolicy;
  if (flowcontroloverrunpolicy) {
    set_has_flowcontroloverrunpolicy();
  } else {
    clear_has_flowcontroloverrunpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t reconcileflowcontrolpolicy = 13;
inline bool dtcpFlowControlConfig_t::has_reconcileflowcontrolpolicy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_reconcileflowcontrolpolicy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void dtcpFlowControlConfig_t::clear_has_reconcileflowcontrolpolicy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void dtcpFlowControlConfig_t::clear_reconcileflowcontrolpolicy() {
  if (reconcileflowcontrolpolicy_ != NULL) reconcileflowcontrolpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_reconcileflowcontrolpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpFlowControlConfig_t::reconcileflowcontrolpolicy() const {
  return reconcileflowcontrolpolicy_ != NULL ? *reconcileflowcontrolpolicy_ : *default_instance_->reconcileflowcontrolpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpFlowControlConfig_t::mutable_reconcileflowcontrolpolicy() {
  set_has_reconcileflowcontrolpolicy();
  if (reconcileflowcontrolpolicy_ == NULL) reconcileflowcontrolpolicy_ = new ::rina::messages::policyDescriptor_t;
  return reconcileflowcontrolpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpFlowControlConfig_t::release_reconcileflowcontrolpolicy() {
  clear_has_reconcileflowcontrolpolicy();
  ::rina::messages::policyDescriptor_t* temp = reconcileflowcontrolpolicy_;
  reconcileflowcontrolpolicy_ = NULL;
  return temp;
}
inline void dtcpFlowControlConfig_t::set_allocated_reconcileflowcontrolpolicy(::rina::messages::policyDescriptor_t* reconcileflowcontrolpolicy) {
  delete reconcileflowcontrolpolicy_;
  reconcileflowcontrolpolicy_ = reconcileflowcontrolpolicy;
  if (reconcileflowcontrolpolicy) {
    set_has_reconcileflowcontrolpolicy();
  } else {
    clear_has_reconcileflowcontrolpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t receivingflowcontrolpolicy = 14;
inline bool dtcpFlowControlConfig_t::has_receivingflowcontrolpolicy() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void dtcpFlowControlConfig_t::set_has_receivingflowcontrolpolicy() {
  _has_bits_[0] |= 0x00002000u;
}
inline void dtcpFlowControlConfig_t::clear_has_receivingflowcontrolpolicy() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void dtcpFlowControlConfig_t::clear_receivingflowcontrolpolicy() {
  if (receivingflowcontrolpolicy_ != NULL) receivingflowcontrolpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_receivingflowcontrolpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpFlowControlConfig_t::receivingflowcontrolpolicy() const {
  return receivingflowcontrolpolicy_ != NULL ? *receivingflowcontrolpolicy_ : *default_instance_->receivingflowcontrolpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpFlowControlConfig_t::mutable_receivingflowcontrolpolicy() {
  set_has_receivingflowcontrolpolicy();
  if (receivingflowcontrolpolicy_ == NULL) receivingflowcontrolpolicy_ = new ::rina::messages::policyDescriptor_t;
  return receivingflowcontrolpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpFlowControlConfig_t::release_receivingflowcontrolpolicy() {
  clear_has_receivingflowcontrolpolicy();
  ::rina::messages::policyDescriptor_t* temp = receivingflowcontrolpolicy_;
  receivingflowcontrolpolicy_ = NULL;
  return temp;
}
inline void dtcpFlowControlConfig_t::set_allocated_receivingflowcontrolpolicy(::rina::messages::policyDescriptor_t* receivingflowcontrolpolicy) {
  delete receivingflowcontrolpolicy_;
  receivingflowcontrolpolicy_ = receivingflowcontrolpolicy;
  if (receivingflowcontrolpolicy) {
    set_has_receivingflowcontrolpolicy();
  } else {
    clear_has_receivingflowcontrolpolicy();
  }
}

// -------------------------------------------------------------------

// dtcpRtxControlConfig_t

// optional uint32 datarxmsnmax = 1;
inline bool dtcpRtxControlConfig_t::has_datarxmsnmax() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dtcpRtxControlConfig_t::set_has_datarxmsnmax() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dtcpRtxControlConfig_t::clear_has_datarxmsnmax() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dtcpRtxControlConfig_t::clear_datarxmsnmax() {
  datarxmsnmax_ = 0u;
  clear_has_datarxmsnmax();
}
inline ::google::protobuf::uint32 dtcpRtxControlConfig_t::datarxmsnmax() const {
  return datarxmsnmax_;
}
inline void dtcpRtxControlConfig_t::set_datarxmsnmax(::google::protobuf::uint32 value) {
  set_has_datarxmsnmax();
  datarxmsnmax_ = value;
}

// optional .rina.messages.policyDescriptor_t rtxtimerexpirypolicy = 2;
inline bool dtcpRtxControlConfig_t::has_rtxtimerexpirypolicy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dtcpRtxControlConfig_t::set_has_rtxtimerexpirypolicy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dtcpRtxControlConfig_t::clear_has_rtxtimerexpirypolicy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dtcpRtxControlConfig_t::clear_rtxtimerexpirypolicy() {
  if (rtxtimerexpirypolicy_ != NULL) rtxtimerexpirypolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_rtxtimerexpirypolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRtxControlConfig_t::rtxtimerexpirypolicy() const {
  return rtxtimerexpirypolicy_ != NULL ? *rtxtimerexpirypolicy_ : *default_instance_->rtxtimerexpirypolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::mutable_rtxtimerexpirypolicy() {
  set_has_rtxtimerexpirypolicy();
  if (rtxtimerexpirypolicy_ == NULL) rtxtimerexpirypolicy_ = new ::rina::messages::policyDescriptor_t;
  return rtxtimerexpirypolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::release_rtxtimerexpirypolicy() {
  clear_has_rtxtimerexpirypolicy();
  ::rina::messages::policyDescriptor_t* temp = rtxtimerexpirypolicy_;
  rtxtimerexpirypolicy_ = NULL;
  return temp;
}
inline void dtcpRtxControlConfig_t::set_allocated_rtxtimerexpirypolicy(::rina::messages::policyDescriptor_t* rtxtimerexpirypolicy) {
  delete rtxtimerexpirypolicy_;
  rtxtimerexpirypolicy_ = rtxtimerexpirypolicy;
  if (rtxtimerexpirypolicy) {
    set_has_rtxtimerexpirypolicy();
  } else {
    clear_has_rtxtimerexpirypolicy();
  }
}

// optional .rina.messages.policyDescriptor_t senderackpolicy = 3;
inline bool dtcpRtxControlConfig_t::has_senderackpolicy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dtcpRtxControlConfig_t::set_has_senderackpolicy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dtcpRtxControlConfig_t::clear_has_senderackpolicy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dtcpRtxControlConfig_t::clear_senderackpolicy() {
  if (senderackpolicy_ != NULL) senderackpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_senderackpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRtxControlConfig_t::senderackpolicy() const {
  return senderackpolicy_ != NULL ? *senderackpolicy_ : *default_instance_->senderackpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::mutable_senderackpolicy() {
  set_has_senderackpolicy();
  if (senderackpolicy_ == NULL) senderackpolicy_ = new ::rina::messages::policyDescriptor_t;
  return senderackpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::release_senderackpolicy() {
  clear_has_senderackpolicy();
  ::rina::messages::policyDescriptor_t* temp = senderackpolicy_;
  senderackpolicy_ = NULL;
  return temp;
}
inline void dtcpRtxControlConfig_t::set_allocated_senderackpolicy(::rina::messages::policyDescriptor_t* senderackpolicy) {
  delete senderackpolicy_;
  senderackpolicy_ = senderackpolicy;
  if (senderackpolicy) {
    set_has_senderackpolicy();
  } else {
    clear_has_senderackpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t recvingacklistpolicy = 4;
inline bool dtcpRtxControlConfig_t::has_recvingacklistpolicy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dtcpRtxControlConfig_t::set_has_recvingacklistpolicy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dtcpRtxControlConfig_t::clear_has_recvingacklistpolicy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dtcpRtxControlConfig_t::clear_recvingacklistpolicy() {
  if (recvingacklistpolicy_ != NULL) recvingacklistpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_recvingacklistpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRtxControlConfig_t::recvingacklistpolicy() const {
  return recvingacklistpolicy_ != NULL ? *recvingacklistpolicy_ : *default_instance_->recvingacklistpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::mutable_recvingacklistpolicy() {
  set_has_recvingacklistpolicy();
  if (recvingacklistpolicy_ == NULL) recvingacklistpolicy_ = new ::rina::messages::policyDescriptor_t;
  return recvingacklistpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::release_recvingacklistpolicy() {
  clear_has_recvingacklistpolicy();
  ::rina::messages::policyDescriptor_t* temp = recvingacklistpolicy_;
  recvingacklistpolicy_ = NULL;
  return temp;
}
inline void dtcpRtxControlConfig_t::set_allocated_recvingacklistpolicy(::rina::messages::policyDescriptor_t* recvingacklistpolicy) {
  delete recvingacklistpolicy_;
  recvingacklistpolicy_ = recvingacklistpolicy;
  if (recvingacklistpolicy) {
    set_has_recvingacklistpolicy();
  } else {
    clear_has_recvingacklistpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t rcvrackpolicy = 5;
inline bool dtcpRtxControlConfig_t::has_rcvrackpolicy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dtcpRtxControlConfig_t::set_has_rcvrackpolicy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dtcpRtxControlConfig_t::clear_has_rcvrackpolicy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dtcpRtxControlConfig_t::clear_rcvrackpolicy() {
  if (rcvrackpolicy_ != NULL) rcvrackpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_rcvrackpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRtxControlConfig_t::rcvrackpolicy() const {
  return rcvrackpolicy_ != NULL ? *rcvrackpolicy_ : *default_instance_->rcvrackpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::mutable_rcvrackpolicy() {
  set_has_rcvrackpolicy();
  if (rcvrackpolicy_ == NULL) rcvrackpolicy_ = new ::rina::messages::policyDescriptor_t;
  return rcvrackpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::release_rcvrackpolicy() {
  clear_has_rcvrackpolicy();
  ::rina::messages::policyDescriptor_t* temp = rcvrackpolicy_;
  rcvrackpolicy_ = NULL;
  return temp;
}
inline void dtcpRtxControlConfig_t::set_allocated_rcvrackpolicy(::rina::messages::policyDescriptor_t* rcvrackpolicy) {
  delete rcvrackpolicy_;
  rcvrackpolicy_ = rcvrackpolicy;
  if (rcvrackpolicy) {
    set_has_rcvrackpolicy();
  } else {
    clear_has_rcvrackpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t sendingackpolicy = 6;
inline bool dtcpRtxControlConfig_t::has_sendingackpolicy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dtcpRtxControlConfig_t::set_has_sendingackpolicy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dtcpRtxControlConfig_t::clear_has_sendingackpolicy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dtcpRtxControlConfig_t::clear_sendingackpolicy() {
  if (sendingackpolicy_ != NULL) sendingackpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_sendingackpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRtxControlConfig_t::sendingackpolicy() const {
  return sendingackpolicy_ != NULL ? *sendingackpolicy_ : *default_instance_->sendingackpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::mutable_sendingackpolicy() {
  set_has_sendingackpolicy();
  if (sendingackpolicy_ == NULL) sendingackpolicy_ = new ::rina::messages::policyDescriptor_t;
  return sendingackpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::release_sendingackpolicy() {
  clear_has_sendingackpolicy();
  ::rina::messages::policyDescriptor_t* temp = sendingackpolicy_;
  sendingackpolicy_ = NULL;
  return temp;
}
inline void dtcpRtxControlConfig_t::set_allocated_sendingackpolicy(::rina::messages::policyDescriptor_t* sendingackpolicy) {
  delete sendingackpolicy_;
  sendingackpolicy_ = sendingackpolicy;
  if (sendingackpolicy) {
    set_has_sendingackpolicy();
  } else {
    clear_has_sendingackpolicy();
  }
}

// optional .rina.messages.policyDescriptor_t rcvrcontrolackpolicy = 7;
inline bool dtcpRtxControlConfig_t::has_rcvrcontrolackpolicy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dtcpRtxControlConfig_t::set_has_rcvrcontrolackpolicy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dtcpRtxControlConfig_t::clear_has_rcvrcontrolackpolicy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dtcpRtxControlConfig_t::clear_rcvrcontrolackpolicy() {
  if (rcvrcontrolackpolicy_ != NULL) rcvrcontrolackpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_rcvrcontrolackpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpRtxControlConfig_t::rcvrcontrolackpolicy() const {
  return rcvrcontrolackpolicy_ != NULL ? *rcvrcontrolackpolicy_ : *default_instance_->rcvrcontrolackpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::mutable_rcvrcontrolackpolicy() {
  set_has_rcvrcontrolackpolicy();
  if (rcvrcontrolackpolicy_ == NULL) rcvrcontrolackpolicy_ = new ::rina::messages::policyDescriptor_t;
  return rcvrcontrolackpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpRtxControlConfig_t::release_rcvrcontrolackpolicy() {
  clear_has_rcvrcontrolackpolicy();
  ::rina::messages::policyDescriptor_t* temp = rcvrcontrolackpolicy_;
  rcvrcontrolackpolicy_ = NULL;
  return temp;
}
inline void dtcpRtxControlConfig_t::set_allocated_rcvrcontrolackpolicy(::rina::messages::policyDescriptor_t* rcvrcontrolackpolicy) {
  delete rcvrcontrolackpolicy_;
  rcvrcontrolackpolicy_ = rcvrcontrolackpolicy;
  if (rcvrcontrolackpolicy) {
    set_has_rcvrcontrolackpolicy();
  } else {
    clear_has_rcvrcontrolackpolicy();
  }
}

// -------------------------------------------------------------------

// dtcpConfig_t

// optional bool flowControl = 1;
inline bool dtcpConfig_t::has_flowcontrol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dtcpConfig_t::set_has_flowcontrol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dtcpConfig_t::clear_has_flowcontrol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dtcpConfig_t::clear_flowcontrol() {
  flowcontrol_ = false;
  clear_has_flowcontrol();
}
inline bool dtcpConfig_t::flowcontrol() const {
  return flowcontrol_;
}
inline void dtcpConfig_t::set_flowcontrol(bool value) {
  set_has_flowcontrol();
  flowcontrol_ = value;
}

// optional .rina.messages.dtcpFlowControlConfig_t flowControlConfig = 2;
inline bool dtcpConfig_t::has_flowcontrolconfig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dtcpConfig_t::set_has_flowcontrolconfig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dtcpConfig_t::clear_has_flowcontrolconfig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dtcpConfig_t::clear_flowcontrolconfig() {
  if (flowcontrolconfig_ != NULL) flowcontrolconfig_->::rina::messages::dtcpFlowControlConfig_t::Clear();
  clear_has_flowcontrolconfig();
}
inline const ::rina::messages::dtcpFlowControlConfig_t& dtcpConfig_t::flowcontrolconfig() const {
  return flowcontrolconfig_ != NULL ? *flowcontrolconfig_ : *default_instance_->flowcontrolconfig_;
}
inline ::rina::messages::dtcpFlowControlConfig_t* dtcpConfig_t::mutable_flowcontrolconfig() {
  set_has_flowcontrolconfig();
  if (flowcontrolconfig_ == NULL) flowcontrolconfig_ = new ::rina::messages::dtcpFlowControlConfig_t;
  return flowcontrolconfig_;
}
inline ::rina::messages::dtcpFlowControlConfig_t* dtcpConfig_t::release_flowcontrolconfig() {
  clear_has_flowcontrolconfig();
  ::rina::messages::dtcpFlowControlConfig_t* temp = flowcontrolconfig_;
  flowcontrolconfig_ = NULL;
  return temp;
}
inline void dtcpConfig_t::set_allocated_flowcontrolconfig(::rina::messages::dtcpFlowControlConfig_t* flowcontrolconfig) {
  delete flowcontrolconfig_;
  flowcontrolconfig_ = flowcontrolconfig;
  if (flowcontrolconfig) {
    set_has_flowcontrolconfig();
  } else {
    clear_has_flowcontrolconfig();
  }
}

// optional bool rtxControl = 3;
inline bool dtcpConfig_t::has_rtxcontrol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dtcpConfig_t::set_has_rtxcontrol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dtcpConfig_t::clear_has_rtxcontrol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dtcpConfig_t::clear_rtxcontrol() {
  rtxcontrol_ = false;
  clear_has_rtxcontrol();
}
inline bool dtcpConfig_t::rtxcontrol() const {
  return rtxcontrol_;
}
inline void dtcpConfig_t::set_rtxcontrol(bool value) {
  set_has_rtxcontrol();
  rtxcontrol_ = value;
}

// optional .rina.messages.dtcpRtxControlConfig_t rtxControlConfig = 4;
inline bool dtcpConfig_t::has_rtxcontrolconfig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dtcpConfig_t::set_has_rtxcontrolconfig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dtcpConfig_t::clear_has_rtxcontrolconfig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dtcpConfig_t::clear_rtxcontrolconfig() {
  if (rtxcontrolconfig_ != NULL) rtxcontrolconfig_->::rina::messages::dtcpRtxControlConfig_t::Clear();
  clear_has_rtxcontrolconfig();
}
inline const ::rina::messages::dtcpRtxControlConfig_t& dtcpConfig_t::rtxcontrolconfig() const {
  return rtxcontrolconfig_ != NULL ? *rtxcontrolconfig_ : *default_instance_->rtxcontrolconfig_;
}
inline ::rina::messages::dtcpRtxControlConfig_t* dtcpConfig_t::mutable_rtxcontrolconfig() {
  set_has_rtxcontrolconfig();
  if (rtxcontrolconfig_ == NULL) rtxcontrolconfig_ = new ::rina::messages::dtcpRtxControlConfig_t;
  return rtxcontrolconfig_;
}
inline ::rina::messages::dtcpRtxControlConfig_t* dtcpConfig_t::release_rtxcontrolconfig() {
  clear_has_rtxcontrolconfig();
  ::rina::messages::dtcpRtxControlConfig_t* temp = rtxcontrolconfig_;
  rtxcontrolconfig_ = NULL;
  return temp;
}
inline void dtcpConfig_t::set_allocated_rtxcontrolconfig(::rina::messages::dtcpRtxControlConfig_t* rtxcontrolconfig) {
  delete rtxcontrolconfig_;
  rtxcontrolconfig_ = rtxcontrolconfig;
  if (rtxcontrolconfig) {
    set_has_rtxcontrolconfig();
  } else {
    clear_has_rtxcontrolconfig();
  }
}

// optional uint32 initialsenderinactivitytime = 5;
inline bool dtcpConfig_t::has_initialsenderinactivitytime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dtcpConfig_t::set_has_initialsenderinactivitytime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dtcpConfig_t::clear_has_initialsenderinactivitytime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dtcpConfig_t::clear_initialsenderinactivitytime() {
  initialsenderinactivitytime_ = 0u;
  clear_has_initialsenderinactivitytime();
}
inline ::google::protobuf::uint32 dtcpConfig_t::initialsenderinactivitytime() const {
  return initialsenderinactivitytime_;
}
inline void dtcpConfig_t::set_initialsenderinactivitytime(::google::protobuf::uint32 value) {
  set_has_initialsenderinactivitytime();
  initialsenderinactivitytime_ = value;
}

// optional uint32 initialrecvrinactivitytime = 6;
inline bool dtcpConfig_t::has_initialrecvrinactivitytime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dtcpConfig_t::set_has_initialrecvrinactivitytime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dtcpConfig_t::clear_has_initialrecvrinactivitytime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dtcpConfig_t::clear_initialrecvrinactivitytime() {
  initialrecvrinactivitytime_ = 0u;
  clear_has_initialrecvrinactivitytime();
}
inline ::google::protobuf::uint32 dtcpConfig_t::initialrecvrinactivitytime() const {
  return initialrecvrinactivitytime_;
}
inline void dtcpConfig_t::set_initialrecvrinactivitytime(::google::protobuf::uint32 value) {
  set_has_initialrecvrinactivitytime();
  initialrecvrinactivitytime_ = value;
}

// optional .rina.messages.policyDescriptor_t rcvrtimerinactivitypolicy = 7;
inline bool dtcpConfig_t::has_rcvrtimerinactivitypolicy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dtcpConfig_t::set_has_rcvrtimerinactivitypolicy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dtcpConfig_t::clear_has_rcvrtimerinactivitypolicy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dtcpConfig_t::clear_rcvrtimerinactivitypolicy() {
  if (rcvrtimerinactivitypolicy_ != NULL) rcvrtimerinactivitypolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_rcvrtimerinactivitypolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpConfig_t::rcvrtimerinactivitypolicy() const {
  return rcvrtimerinactivitypolicy_ != NULL ? *rcvrtimerinactivitypolicy_ : *default_instance_->rcvrtimerinactivitypolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpConfig_t::mutable_rcvrtimerinactivitypolicy() {
  set_has_rcvrtimerinactivitypolicy();
  if (rcvrtimerinactivitypolicy_ == NULL) rcvrtimerinactivitypolicy_ = new ::rina::messages::policyDescriptor_t;
  return rcvrtimerinactivitypolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpConfig_t::release_rcvrtimerinactivitypolicy() {
  clear_has_rcvrtimerinactivitypolicy();
  ::rina::messages::policyDescriptor_t* temp = rcvrtimerinactivitypolicy_;
  rcvrtimerinactivitypolicy_ = NULL;
  return temp;
}
inline void dtcpConfig_t::set_allocated_rcvrtimerinactivitypolicy(::rina::messages::policyDescriptor_t* rcvrtimerinactivitypolicy) {
  delete rcvrtimerinactivitypolicy_;
  rcvrtimerinactivitypolicy_ = rcvrtimerinactivitypolicy;
  if (rcvrtimerinactivitypolicy) {
    set_has_rcvrtimerinactivitypolicy();
  } else {
    clear_has_rcvrtimerinactivitypolicy();
  }
}

// optional .rina.messages.policyDescriptor_t sendertimerinactiviypolicy = 8;
inline bool dtcpConfig_t::has_sendertimerinactiviypolicy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dtcpConfig_t::set_has_sendertimerinactiviypolicy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void dtcpConfig_t::clear_has_sendertimerinactiviypolicy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void dtcpConfig_t::clear_sendertimerinactiviypolicy() {
  if (sendertimerinactiviypolicy_ != NULL) sendertimerinactiviypolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_sendertimerinactiviypolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpConfig_t::sendertimerinactiviypolicy() const {
  return sendertimerinactiviypolicy_ != NULL ? *sendertimerinactiviypolicy_ : *default_instance_->sendertimerinactiviypolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpConfig_t::mutable_sendertimerinactiviypolicy() {
  set_has_sendertimerinactiviypolicy();
  if (sendertimerinactiviypolicy_ == NULL) sendertimerinactiviypolicy_ = new ::rina::messages::policyDescriptor_t;
  return sendertimerinactiviypolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpConfig_t::release_sendertimerinactiviypolicy() {
  clear_has_sendertimerinactiviypolicy();
  ::rina::messages::policyDescriptor_t* temp = sendertimerinactiviypolicy_;
  sendertimerinactiviypolicy_ = NULL;
  return temp;
}
inline void dtcpConfig_t::set_allocated_sendertimerinactiviypolicy(::rina::messages::policyDescriptor_t* sendertimerinactiviypolicy) {
  delete sendertimerinactiviypolicy_;
  sendertimerinactiviypolicy_ = sendertimerinactiviypolicy;
  if (sendertimerinactiviypolicy) {
    set_has_sendertimerinactiviypolicy();
  } else {
    clear_has_sendertimerinactiviypolicy();
  }
}

// optional .rina.messages.policyDescriptor_t lostcontrolpdupolicy = 9;
inline bool dtcpConfig_t::has_lostcontrolpdupolicy() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dtcpConfig_t::set_has_lostcontrolpdupolicy() {
  _has_bits_[0] |= 0x00000100u;
}
inline void dtcpConfig_t::clear_has_lostcontrolpdupolicy() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void dtcpConfig_t::clear_lostcontrolpdupolicy() {
  if (lostcontrolpdupolicy_ != NULL) lostcontrolpdupolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_lostcontrolpdupolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpConfig_t::lostcontrolpdupolicy() const {
  return lostcontrolpdupolicy_ != NULL ? *lostcontrolpdupolicy_ : *default_instance_->lostcontrolpdupolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpConfig_t::mutable_lostcontrolpdupolicy() {
  set_has_lostcontrolpdupolicy();
  if (lostcontrolpdupolicy_ == NULL) lostcontrolpdupolicy_ = new ::rina::messages::policyDescriptor_t;
  return lostcontrolpdupolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpConfig_t::release_lostcontrolpdupolicy() {
  clear_has_lostcontrolpdupolicy();
  ::rina::messages::policyDescriptor_t* temp = lostcontrolpdupolicy_;
  lostcontrolpdupolicy_ = NULL;
  return temp;
}
inline void dtcpConfig_t::set_allocated_lostcontrolpdupolicy(::rina::messages::policyDescriptor_t* lostcontrolpdupolicy) {
  delete lostcontrolpdupolicy_;
  lostcontrolpdupolicy_ = lostcontrolpdupolicy;
  if (lostcontrolpdupolicy) {
    set_has_lostcontrolpdupolicy();
  } else {
    clear_has_lostcontrolpdupolicy();
  }
}

// optional .rina.messages.policyDescriptor_t rttestimatorpolicy = 10;
inline bool dtcpConfig_t::has_rttestimatorpolicy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void dtcpConfig_t::set_has_rttestimatorpolicy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void dtcpConfig_t::clear_has_rttestimatorpolicy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void dtcpConfig_t::clear_rttestimatorpolicy() {
  if (rttestimatorpolicy_ != NULL) rttestimatorpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_rttestimatorpolicy();
}
inline const ::rina::messages::policyDescriptor_t& dtcpConfig_t::rttestimatorpolicy() const {
  return rttestimatorpolicy_ != NULL ? *rttestimatorpolicy_ : *default_instance_->rttestimatorpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpConfig_t::mutable_rttestimatorpolicy() {
  set_has_rttestimatorpolicy();
  if (rttestimatorpolicy_ == NULL) rttestimatorpolicy_ = new ::rina::messages::policyDescriptor_t;
  return rttestimatorpolicy_;
}
inline ::rina::messages::policyDescriptor_t* dtcpConfig_t::release_rttestimatorpolicy() {
  clear_has_rttestimatorpolicy();
  ::rina::messages::policyDescriptor_t* temp = rttestimatorpolicy_;
  rttestimatorpolicy_ = NULL;
  return temp;
}
inline void dtcpConfig_t::set_allocated_rttestimatorpolicy(::rina::messages::policyDescriptor_t* rttestimatorpolicy) {
  delete rttestimatorpolicy_;
  rttestimatorpolicy_ = rttestimatorpolicy;
  if (rttestimatorpolicy) {
    set_has_rttestimatorpolicy();
  } else {
    clear_has_rttestimatorpolicy();
  }
}

// -------------------------------------------------------------------

// connectionPolicies_t

// optional bool dtcpPresent = 1;
inline bool connectionPolicies_t::has_dtcppresent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connectionPolicies_t::set_has_dtcppresent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connectionPolicies_t::clear_has_dtcppresent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connectionPolicies_t::clear_dtcppresent() {
  dtcppresent_ = false;
  clear_has_dtcppresent();
}
inline bool connectionPolicies_t::dtcppresent() const {
  return dtcppresent_;
}
inline void connectionPolicies_t::set_dtcppresent(bool value) {
  set_has_dtcppresent();
  dtcppresent_ = value;
}

// optional .rina.messages.dtcpConfig_t dtcpConfiguration = 2;
inline bool connectionPolicies_t::has_dtcpconfiguration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connectionPolicies_t::set_has_dtcpconfiguration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connectionPolicies_t::clear_has_dtcpconfiguration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connectionPolicies_t::clear_dtcpconfiguration() {
  if (dtcpconfiguration_ != NULL) dtcpconfiguration_->::rina::messages::dtcpConfig_t::Clear();
  clear_has_dtcpconfiguration();
}
inline const ::rina::messages::dtcpConfig_t& connectionPolicies_t::dtcpconfiguration() const {
  return dtcpconfiguration_ != NULL ? *dtcpconfiguration_ : *default_instance_->dtcpconfiguration_;
}
inline ::rina::messages::dtcpConfig_t* connectionPolicies_t::mutable_dtcpconfiguration() {
  set_has_dtcpconfiguration();
  if (dtcpconfiguration_ == NULL) dtcpconfiguration_ = new ::rina::messages::dtcpConfig_t;
  return dtcpconfiguration_;
}
inline ::rina::messages::dtcpConfig_t* connectionPolicies_t::release_dtcpconfiguration() {
  clear_has_dtcpconfiguration();
  ::rina::messages::dtcpConfig_t* temp = dtcpconfiguration_;
  dtcpconfiguration_ = NULL;
  return temp;
}
inline void connectionPolicies_t::set_allocated_dtcpconfiguration(::rina::messages::dtcpConfig_t* dtcpconfiguration) {
  delete dtcpconfiguration_;
  dtcpconfiguration_ = dtcpconfiguration;
  if (dtcpconfiguration) {
    set_has_dtcpconfiguration();
  } else {
    clear_has_dtcpconfiguration();
  }
}

// optional .rina.messages.policyDescriptor_t initialseqnumpolicy = 3;
inline bool connectionPolicies_t::has_initialseqnumpolicy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void connectionPolicies_t::set_has_initialseqnumpolicy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void connectionPolicies_t::clear_has_initialseqnumpolicy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void connectionPolicies_t::clear_initialseqnumpolicy() {
  if (initialseqnumpolicy_ != NULL) initialseqnumpolicy_->::rina::messages::policyDescriptor_t::Clear();
  clear_has_initialseqnumpolicy();
}
inline const ::rina::messages::policyDescriptor_t& connectionPolicies_t::initialseqnumpolicy() const {
  return initialseqnumpolicy_ != NULL ? *initialseqnumpolicy_ : *default_instance_->initialseqnumpolicy_;
}
inline ::rina::messages::policyDescriptor_t* connectionPolicies_t::mutable_initialseqnumpolicy() {
  set_has_initialseqnumpolicy();
  if (initialseqnumpolicy_ == NULL) initialseqnumpolicy_ = new ::rina::messages::policyDescriptor_t;
  return initialseqnumpolicy_;
}
inline ::rina::messages::policyDescriptor_t* connectionPolicies_t::release_initialseqnumpolicy() {
  clear_has_initialseqnumpolicy();
  ::rina::messages::policyDescriptor_t* temp = initialseqnumpolicy_;
  initialseqnumpolicy_ = NULL;
  return temp;
}
inline void connectionPolicies_t::set_allocated_initialseqnumpolicy(::rina::messages::policyDescriptor_t* initialseqnumpolicy) {
  delete initialseqnumpolicy_;
  initialseqnumpolicy_ = initialseqnumpolicy;
  if (initialseqnumpolicy) {
    set_has_initialseqnumpolicy();
  } else {
    clear_has_initialseqnumpolicy();
  }
}

// optional uint64 seqnumrolloverthreshold = 4;
inline bool connectionPolicies_t::has_seqnumrolloverthreshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void connectionPolicies_t::set_has_seqnumrolloverthreshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void connectionPolicies_t::clear_has_seqnumrolloverthreshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void connectionPolicies_t::clear_seqnumrolloverthreshold() {
  seqnumrolloverthreshold_ = GOOGLE_ULONGLONG(0);
  clear_has_seqnumrolloverthreshold();
}
inline ::google::protobuf::uint64 connectionPolicies_t::seqnumrolloverthreshold() const {
  return seqnumrolloverthreshold_;
}
inline void connectionPolicies_t::set_seqnumrolloverthreshold(::google::protobuf::uint64 value) {
  set_has_seqnumrolloverthreshold();
  seqnumrolloverthreshold_ = value;
}

// optional uint32 initialATimer = 5;
inline bool connectionPolicies_t::has_initialatimer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void connectionPolicies_t::set_has_initialatimer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void connectionPolicies_t::clear_has_initialatimer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void connectionPolicies_t::clear_initialatimer() {
  initialatimer_ = 0u;
  clear_has_initialatimer();
}
inline ::google::protobuf::uint32 connectionPolicies_t::initialatimer() const {
  return initialatimer_;
}
inline void connectionPolicies_t::set_initialatimer(::google::protobuf::uint32 value) {
  set_has_initialatimer();
  initialatimer_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace rina

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ConnectionPoliciesMessage_2eproto__INCLUDED
