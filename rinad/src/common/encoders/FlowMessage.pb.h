// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FlowMessage.proto

#ifndef PROTOBUF_FlowMessage_2eproto__INCLUDED
#define PROTOBUF_FlowMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ApplicationProcessNamingInfoMessage.pb.h"
#include "QoSSpecification.pb.h"
#include "ConnectionPoliciesMessage.pb.h"
// @@protoc_insertion_point(includes)

namespace rina {
namespace messages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FlowMessage_2eproto();
void protobuf_AssignDesc_FlowMessage_2eproto();
void protobuf_ShutdownFile_FlowMessage_2eproto();

class connectionId_t;
class Flow;

// ===================================================================

class connectionId_t : public ::google::protobuf::Message {
 public:
  connectionId_t();
  virtual ~connectionId_t();

  connectionId_t(const connectionId_t& from);

  inline connectionId_t& operator=(const connectionId_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const connectionId_t& default_instance();

  void Swap(connectionId_t* other);

  // implements Message ----------------------------------------------

  connectionId_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const connectionId_t& from);
  void MergeFrom(const connectionId_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 qosId = 1;
  inline bool has_qosid() const;
  inline void clear_qosid();
  static const int kQosIdFieldNumber = 1;
  inline ::google::protobuf::uint32 qosid() const;
  inline void set_qosid(::google::protobuf::uint32 value);

  // optional uint32 sourceCEPId = 2;
  inline bool has_sourcecepid() const;
  inline void clear_sourcecepid();
  static const int kSourceCEPIdFieldNumber = 2;
  inline ::google::protobuf::uint32 sourcecepid() const;
  inline void set_sourcecepid(::google::protobuf::uint32 value);

  // optional uint32 destinationCEPId = 3;
  inline bool has_destinationcepid() const;
  inline void clear_destinationcepid();
  static const int kDestinationCEPIdFieldNumber = 3;
  inline ::google::protobuf::uint32 destinationcepid() const;
  inline void set_destinationcepid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rina.messages.connectionId_t)
 private:
  inline void set_has_qosid();
  inline void clear_has_qosid();
  inline void set_has_sourcecepid();
  inline void clear_has_sourcecepid();
  inline void set_has_destinationcepid();
  inline void clear_has_destinationcepid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 qosid_;
  ::google::protobuf::uint32 sourcecepid_;
  ::google::protobuf::uint32 destinationcepid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_FlowMessage_2eproto();
  friend void protobuf_AssignDesc_FlowMessage_2eproto();
  friend void protobuf_ShutdownFile_FlowMessage_2eproto();

  void InitAsDefaultInstance();
  static connectionId_t* default_instance_;
};
// -------------------------------------------------------------------

class Flow : public ::google::protobuf::Message {
 public:
  Flow();
  virtual ~Flow();

  Flow(const Flow& from);

  inline Flow& operator=(const Flow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Flow& default_instance();

  void Swap(Flow* other);

  // implements Message ----------------------------------------------

  Flow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Flow& from);
  void MergeFrom(const Flow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .rina.messages.applicationProcessNamingInfo_t sourceNamingInfo = 1;
  inline bool has_sourcenaminginfo() const;
  inline void clear_sourcenaminginfo();
  static const int kSourceNamingInfoFieldNumber = 1;
  inline const ::rina::messages::applicationProcessNamingInfo_t& sourcenaminginfo() const;
  inline ::rina::messages::applicationProcessNamingInfo_t* mutable_sourcenaminginfo();
  inline ::rina::messages::applicationProcessNamingInfo_t* release_sourcenaminginfo();
  inline void set_allocated_sourcenaminginfo(::rina::messages::applicationProcessNamingInfo_t* sourcenaminginfo);

  // required .rina.messages.applicationProcessNamingInfo_t destinationNamingInfo = 2;
  inline bool has_destinationnaminginfo() const;
  inline void clear_destinationnaminginfo();
  static const int kDestinationNamingInfoFieldNumber = 2;
  inline const ::rina::messages::applicationProcessNamingInfo_t& destinationnaminginfo() const;
  inline ::rina::messages::applicationProcessNamingInfo_t* mutable_destinationnaminginfo();
  inline ::rina::messages::applicationProcessNamingInfo_t* release_destinationnaminginfo();
  inline void set_allocated_destinationnaminginfo(::rina::messages::applicationProcessNamingInfo_t* destinationnaminginfo);

  // required uint64 sourcePortId = 3;
  inline bool has_sourceportid() const;
  inline void clear_sourceportid();
  static const int kSourcePortIdFieldNumber = 3;
  inline ::google::protobuf::uint64 sourceportid() const;
  inline void set_sourceportid(::google::protobuf::uint64 value);

  // optional uint64 destinationPortId = 4;
  inline bool has_destinationportid() const;
  inline void clear_destinationportid();
  static const int kDestinationPortIdFieldNumber = 4;
  inline ::google::protobuf::uint64 destinationportid() const;
  inline void set_destinationportid(::google::protobuf::uint64 value);

  // required uint64 sourceAddress = 5;
  inline bool has_sourceaddress() const;
  inline void clear_sourceaddress();
  static const int kSourceAddressFieldNumber = 5;
  inline ::google::protobuf::uint64 sourceaddress() const;
  inline void set_sourceaddress(::google::protobuf::uint64 value);

  // optional uint64 destinationAddress = 6;
  inline bool has_destinationaddress() const;
  inline void clear_destinationaddress();
  static const int kDestinationAddressFieldNumber = 6;
  inline ::google::protobuf::uint64 destinationaddress() const;
  inline void set_destinationaddress(::google::protobuf::uint64 value);

  // repeated .rina.messages.connectionId_t connectionIds = 7;
  inline int connectionids_size() const;
  inline void clear_connectionids();
  static const int kConnectionIdsFieldNumber = 7;
  inline const ::rina::messages::connectionId_t& connectionids(int index) const;
  inline ::rina::messages::connectionId_t* mutable_connectionids(int index);
  inline ::rina::messages::connectionId_t* add_connectionids();
  inline const ::google::protobuf::RepeatedPtrField< ::rina::messages::connectionId_t >&
      connectionids() const;
  inline ::google::protobuf::RepeatedPtrField< ::rina::messages::connectionId_t >*
      mutable_connectionids();

  // optional uint32 currentConnectionIdIndex = 8;
  inline bool has_currentconnectionidindex() const;
  inline void clear_currentconnectionidindex();
  static const int kCurrentConnectionIdIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 currentconnectionidindex() const;
  inline void set_currentconnectionidindex(::google::protobuf::uint32 value);

  // optional uint32 state = 9;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 9;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional .rina.messages.qosSpecification_t qosParameters = 10;
  inline bool has_qosparameters() const;
  inline void clear_qosparameters();
  static const int kQosParametersFieldNumber = 10;
  inline const ::rina::messages::qosSpecification_t& qosparameters() const;
  inline ::rina::messages::qosSpecification_t* mutable_qosparameters();
  inline ::rina::messages::qosSpecification_t* release_qosparameters();
  inline void set_allocated_qosparameters(::rina::messages::qosSpecification_t* qosparameters);

  // optional .rina.messages.connectionPolicies_t connectionPolicies = 11;
  inline bool has_connectionpolicies() const;
  inline void clear_connectionpolicies();
  static const int kConnectionPoliciesFieldNumber = 11;
  inline const ::rina::messages::connectionPolicies_t& connectionpolicies() const;
  inline ::rina::messages::connectionPolicies_t* mutable_connectionpolicies();
  inline ::rina::messages::connectionPolicies_t* release_connectionpolicies();
  inline void set_allocated_connectionpolicies(::rina::messages::connectionPolicies_t* connectionpolicies);

  // optional bytes accessControl = 12;
  inline bool has_accesscontrol() const;
  inline void clear_accesscontrol();
  static const int kAccessControlFieldNumber = 12;
  inline const ::std::string& accesscontrol() const;
  inline void set_accesscontrol(const ::std::string& value);
  inline void set_accesscontrol(const char* value);
  inline void set_accesscontrol(const void* value, size_t size);
  inline ::std::string* mutable_accesscontrol();
  inline ::std::string* release_accesscontrol();
  inline void set_allocated_accesscontrol(::std::string* accesscontrol);

  // optional uint32 maxCreateFlowRetries = 13;
  inline bool has_maxcreateflowretries() const;
  inline void clear_maxcreateflowretries();
  static const int kMaxCreateFlowRetriesFieldNumber = 13;
  inline ::google::protobuf::uint32 maxcreateflowretries() const;
  inline void set_maxcreateflowretries(::google::protobuf::uint32 value);

  // optional uint32 createFlowRetries = 14;
  inline bool has_createflowretries() const;
  inline void clear_createflowretries();
  static const int kCreateFlowRetriesFieldNumber = 14;
  inline ::google::protobuf::uint32 createflowretries() const;
  inline void set_createflowretries(::google::protobuf::uint32 value);

  // optional uint32 hopCount = 15;
  inline bool has_hopcount() const;
  inline void clear_hopcount();
  static const int kHopCountFieldNumber = 15;
  inline ::google::protobuf::uint32 hopcount() const;
  inline void set_hopcount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:rina.messages.Flow)
 private:
  inline void set_has_sourcenaminginfo();
  inline void clear_has_sourcenaminginfo();
  inline void set_has_destinationnaminginfo();
  inline void clear_has_destinationnaminginfo();
  inline void set_has_sourceportid();
  inline void clear_has_sourceportid();
  inline void set_has_destinationportid();
  inline void clear_has_destinationportid();
  inline void set_has_sourceaddress();
  inline void clear_has_sourceaddress();
  inline void set_has_destinationaddress();
  inline void clear_has_destinationaddress();
  inline void set_has_currentconnectionidindex();
  inline void clear_has_currentconnectionidindex();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_qosparameters();
  inline void clear_has_qosparameters();
  inline void set_has_connectionpolicies();
  inline void clear_has_connectionpolicies();
  inline void set_has_accesscontrol();
  inline void clear_has_accesscontrol();
  inline void set_has_maxcreateflowretries();
  inline void clear_has_maxcreateflowretries();
  inline void set_has_createflowretries();
  inline void clear_has_createflowretries();
  inline void set_has_hopcount();
  inline void clear_has_hopcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rina::messages::applicationProcessNamingInfo_t* sourcenaminginfo_;
  ::rina::messages::applicationProcessNamingInfo_t* destinationnaminginfo_;
  ::google::protobuf::uint64 sourceportid_;
  ::google::protobuf::uint64 destinationportid_;
  ::google::protobuf::uint64 sourceaddress_;
  ::google::protobuf::uint64 destinationaddress_;
  ::google::protobuf::RepeatedPtrField< ::rina::messages::connectionId_t > connectionids_;
  ::google::protobuf::uint32 currentconnectionidindex_;
  ::google::protobuf::uint32 state_;
  ::rina::messages::qosSpecification_t* qosparameters_;
  ::rina::messages::connectionPolicies_t* connectionpolicies_;
  ::std::string* accesscontrol_;
  ::google::protobuf::uint32 maxcreateflowretries_;
  ::google::protobuf::uint32 createflowretries_;
  ::google::protobuf::uint32 hopcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_FlowMessage_2eproto();
  friend void protobuf_AssignDesc_FlowMessage_2eproto();
  friend void protobuf_ShutdownFile_FlowMessage_2eproto();

  void InitAsDefaultInstance();
  static Flow* default_instance_;
};
// ===================================================================


// ===================================================================

// connectionId_t

// optional uint32 qosId = 1;
inline bool connectionId_t::has_qosid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void connectionId_t::set_has_qosid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void connectionId_t::clear_has_qosid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void connectionId_t::clear_qosid() {
  qosid_ = 0u;
  clear_has_qosid();
}
inline ::google::protobuf::uint32 connectionId_t::qosid() const {
  return qosid_;
}
inline void connectionId_t::set_qosid(::google::protobuf::uint32 value) {
  set_has_qosid();
  qosid_ = value;
}

// optional uint32 sourceCEPId = 2;
inline bool connectionId_t::has_sourcecepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void connectionId_t::set_has_sourcecepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void connectionId_t::clear_has_sourcecepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void connectionId_t::clear_sourcecepid() {
  sourcecepid_ = 0u;
  clear_has_sourcecepid();
}
inline ::google::protobuf::uint32 connectionId_t::sourcecepid() const {
  return sourcecepid_;
}
inline void connectionId_t::set_sourcecepid(::google::protobuf::uint32 value) {
  set_has_sourcecepid();
  sourcecepid_ = value;
}

// optional uint32 destinationCEPId = 3;
inline bool connectionId_t::has_destinationcepid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void connectionId_t::set_has_destinationcepid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void connectionId_t::clear_has_destinationcepid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void connectionId_t::clear_destinationcepid() {
  destinationcepid_ = 0u;
  clear_has_destinationcepid();
}
inline ::google::protobuf::uint32 connectionId_t::destinationcepid() const {
  return destinationcepid_;
}
inline void connectionId_t::set_destinationcepid(::google::protobuf::uint32 value) {
  set_has_destinationcepid();
  destinationcepid_ = value;
}

// -------------------------------------------------------------------

// Flow

// required .rina.messages.applicationProcessNamingInfo_t sourceNamingInfo = 1;
inline bool Flow::has_sourcenaminginfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Flow::set_has_sourcenaminginfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Flow::clear_has_sourcenaminginfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Flow::clear_sourcenaminginfo() {
  if (sourcenaminginfo_ != NULL) sourcenaminginfo_->::rina::messages::applicationProcessNamingInfo_t::Clear();
  clear_has_sourcenaminginfo();
}
inline const ::rina::messages::applicationProcessNamingInfo_t& Flow::sourcenaminginfo() const {
  return sourcenaminginfo_ != NULL ? *sourcenaminginfo_ : *default_instance_->sourcenaminginfo_;
}
inline ::rina::messages::applicationProcessNamingInfo_t* Flow::mutable_sourcenaminginfo() {
  set_has_sourcenaminginfo();
  if (sourcenaminginfo_ == NULL) sourcenaminginfo_ = new ::rina::messages::applicationProcessNamingInfo_t;
  return sourcenaminginfo_;
}
inline ::rina::messages::applicationProcessNamingInfo_t* Flow::release_sourcenaminginfo() {
  clear_has_sourcenaminginfo();
  ::rina::messages::applicationProcessNamingInfo_t* temp = sourcenaminginfo_;
  sourcenaminginfo_ = NULL;
  return temp;
}
inline void Flow::set_allocated_sourcenaminginfo(::rina::messages::applicationProcessNamingInfo_t* sourcenaminginfo) {
  delete sourcenaminginfo_;
  sourcenaminginfo_ = sourcenaminginfo;
  if (sourcenaminginfo) {
    set_has_sourcenaminginfo();
  } else {
    clear_has_sourcenaminginfo();
  }
}

// required .rina.messages.applicationProcessNamingInfo_t destinationNamingInfo = 2;
inline bool Flow::has_destinationnaminginfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Flow::set_has_destinationnaminginfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Flow::clear_has_destinationnaminginfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Flow::clear_destinationnaminginfo() {
  if (destinationnaminginfo_ != NULL) destinationnaminginfo_->::rina::messages::applicationProcessNamingInfo_t::Clear();
  clear_has_destinationnaminginfo();
}
inline const ::rina::messages::applicationProcessNamingInfo_t& Flow::destinationnaminginfo() const {
  return destinationnaminginfo_ != NULL ? *destinationnaminginfo_ : *default_instance_->destinationnaminginfo_;
}
inline ::rina::messages::applicationProcessNamingInfo_t* Flow::mutable_destinationnaminginfo() {
  set_has_destinationnaminginfo();
  if (destinationnaminginfo_ == NULL) destinationnaminginfo_ = new ::rina::messages::applicationProcessNamingInfo_t;
  return destinationnaminginfo_;
}
inline ::rina::messages::applicationProcessNamingInfo_t* Flow::release_destinationnaminginfo() {
  clear_has_destinationnaminginfo();
  ::rina::messages::applicationProcessNamingInfo_t* temp = destinationnaminginfo_;
  destinationnaminginfo_ = NULL;
  return temp;
}
inline void Flow::set_allocated_destinationnaminginfo(::rina::messages::applicationProcessNamingInfo_t* destinationnaminginfo) {
  delete destinationnaminginfo_;
  destinationnaminginfo_ = destinationnaminginfo;
  if (destinationnaminginfo) {
    set_has_destinationnaminginfo();
  } else {
    clear_has_destinationnaminginfo();
  }
}

// required uint64 sourcePortId = 3;
inline bool Flow::has_sourceportid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Flow::set_has_sourceportid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Flow::clear_has_sourceportid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Flow::clear_sourceportid() {
  sourceportid_ = GOOGLE_ULONGLONG(0);
  clear_has_sourceportid();
}
inline ::google::protobuf::uint64 Flow::sourceportid() const {
  return sourceportid_;
}
inline void Flow::set_sourceportid(::google::protobuf::uint64 value) {
  set_has_sourceportid();
  sourceportid_ = value;
}

// optional uint64 destinationPortId = 4;
inline bool Flow::has_destinationportid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Flow::set_has_destinationportid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Flow::clear_has_destinationportid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Flow::clear_destinationportid() {
  destinationportid_ = GOOGLE_ULONGLONG(0);
  clear_has_destinationportid();
}
inline ::google::protobuf::uint64 Flow::destinationportid() const {
  return destinationportid_;
}
inline void Flow::set_destinationportid(::google::protobuf::uint64 value) {
  set_has_destinationportid();
  destinationportid_ = value;
}

// required uint64 sourceAddress = 5;
inline bool Flow::has_sourceaddress() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Flow::set_has_sourceaddress() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Flow::clear_has_sourceaddress() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Flow::clear_sourceaddress() {
  sourceaddress_ = GOOGLE_ULONGLONG(0);
  clear_has_sourceaddress();
}
inline ::google::protobuf::uint64 Flow::sourceaddress() const {
  return sourceaddress_;
}
inline void Flow::set_sourceaddress(::google::protobuf::uint64 value) {
  set_has_sourceaddress();
  sourceaddress_ = value;
}

// optional uint64 destinationAddress = 6;
inline bool Flow::has_destinationaddress() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Flow::set_has_destinationaddress() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Flow::clear_has_destinationaddress() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Flow::clear_destinationaddress() {
  destinationaddress_ = GOOGLE_ULONGLONG(0);
  clear_has_destinationaddress();
}
inline ::google::protobuf::uint64 Flow::destinationaddress() const {
  return destinationaddress_;
}
inline void Flow::set_destinationaddress(::google::protobuf::uint64 value) {
  set_has_destinationaddress();
  destinationaddress_ = value;
}

// repeated .rina.messages.connectionId_t connectionIds = 7;
inline int Flow::connectionids_size() const {
  return connectionids_.size();
}
inline void Flow::clear_connectionids() {
  connectionids_.Clear();
}
inline const ::rina::messages::connectionId_t& Flow::connectionids(int index) const {
  return connectionids_.Get(index);
}
inline ::rina::messages::connectionId_t* Flow::mutable_connectionids(int index) {
  return connectionids_.Mutable(index);
}
inline ::rina::messages::connectionId_t* Flow::add_connectionids() {
  return connectionids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rina::messages::connectionId_t >&
Flow::connectionids() const {
  return connectionids_;
}
inline ::google::protobuf::RepeatedPtrField< ::rina::messages::connectionId_t >*
Flow::mutable_connectionids() {
  return &connectionids_;
}

// optional uint32 currentConnectionIdIndex = 8;
inline bool Flow::has_currentconnectionidindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Flow::set_has_currentconnectionidindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Flow::clear_has_currentconnectionidindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Flow::clear_currentconnectionidindex() {
  currentconnectionidindex_ = 0u;
  clear_has_currentconnectionidindex();
}
inline ::google::protobuf::uint32 Flow::currentconnectionidindex() const {
  return currentconnectionidindex_;
}
inline void Flow::set_currentconnectionidindex(::google::protobuf::uint32 value) {
  set_has_currentconnectionidindex();
  currentconnectionidindex_ = value;
}

// optional uint32 state = 9;
inline bool Flow::has_state() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Flow::set_has_state() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Flow::clear_has_state() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Flow::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 Flow::state() const {
  return state_;
}
inline void Flow::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional .rina.messages.qosSpecification_t qosParameters = 10;
inline bool Flow::has_qosparameters() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Flow::set_has_qosparameters() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Flow::clear_has_qosparameters() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Flow::clear_qosparameters() {
  if (qosparameters_ != NULL) qosparameters_->::rina::messages::qosSpecification_t::Clear();
  clear_has_qosparameters();
}
inline const ::rina::messages::qosSpecification_t& Flow::qosparameters() const {
  return qosparameters_ != NULL ? *qosparameters_ : *default_instance_->qosparameters_;
}
inline ::rina::messages::qosSpecification_t* Flow::mutable_qosparameters() {
  set_has_qosparameters();
  if (qosparameters_ == NULL) qosparameters_ = new ::rina::messages::qosSpecification_t;
  return qosparameters_;
}
inline ::rina::messages::qosSpecification_t* Flow::release_qosparameters() {
  clear_has_qosparameters();
  ::rina::messages::qosSpecification_t* temp = qosparameters_;
  qosparameters_ = NULL;
  return temp;
}
inline void Flow::set_allocated_qosparameters(::rina::messages::qosSpecification_t* qosparameters) {
  delete qosparameters_;
  qosparameters_ = qosparameters;
  if (qosparameters) {
    set_has_qosparameters();
  } else {
    clear_has_qosparameters();
  }
}

// optional .rina.messages.connectionPolicies_t connectionPolicies = 11;
inline bool Flow::has_connectionpolicies() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Flow::set_has_connectionpolicies() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Flow::clear_has_connectionpolicies() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Flow::clear_connectionpolicies() {
  if (connectionpolicies_ != NULL) connectionpolicies_->::rina::messages::connectionPolicies_t::Clear();
  clear_has_connectionpolicies();
}
inline const ::rina::messages::connectionPolicies_t& Flow::connectionpolicies() const {
  return connectionpolicies_ != NULL ? *connectionpolicies_ : *default_instance_->connectionpolicies_;
}
inline ::rina::messages::connectionPolicies_t* Flow::mutable_connectionpolicies() {
  set_has_connectionpolicies();
  if (connectionpolicies_ == NULL) connectionpolicies_ = new ::rina::messages::connectionPolicies_t;
  return connectionpolicies_;
}
inline ::rina::messages::connectionPolicies_t* Flow::release_connectionpolicies() {
  clear_has_connectionpolicies();
  ::rina::messages::connectionPolicies_t* temp = connectionpolicies_;
  connectionpolicies_ = NULL;
  return temp;
}
inline void Flow::set_allocated_connectionpolicies(::rina::messages::connectionPolicies_t* connectionpolicies) {
  delete connectionpolicies_;
  connectionpolicies_ = connectionpolicies;
  if (connectionpolicies) {
    set_has_connectionpolicies();
  } else {
    clear_has_connectionpolicies();
  }
}

// optional bytes accessControl = 12;
inline bool Flow::has_accesscontrol() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Flow::set_has_accesscontrol() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Flow::clear_has_accesscontrol() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Flow::clear_accesscontrol() {
  if (accesscontrol_ != &::google::protobuf::internal::kEmptyString) {
    accesscontrol_->clear();
  }
  clear_has_accesscontrol();
}
inline const ::std::string& Flow::accesscontrol() const {
  return *accesscontrol_;
}
inline void Flow::set_accesscontrol(const ::std::string& value) {
  set_has_accesscontrol();
  if (accesscontrol_ == &::google::protobuf::internal::kEmptyString) {
    accesscontrol_ = new ::std::string;
  }
  accesscontrol_->assign(value);
}
inline void Flow::set_accesscontrol(const char* value) {
  set_has_accesscontrol();
  if (accesscontrol_ == &::google::protobuf::internal::kEmptyString) {
    accesscontrol_ = new ::std::string;
  }
  accesscontrol_->assign(value);
}
inline void Flow::set_accesscontrol(const void* value, size_t size) {
  set_has_accesscontrol();
  if (accesscontrol_ == &::google::protobuf::internal::kEmptyString) {
    accesscontrol_ = new ::std::string;
  }
  accesscontrol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Flow::mutable_accesscontrol() {
  set_has_accesscontrol();
  if (accesscontrol_ == &::google::protobuf::internal::kEmptyString) {
    accesscontrol_ = new ::std::string;
  }
  return accesscontrol_;
}
inline ::std::string* Flow::release_accesscontrol() {
  clear_has_accesscontrol();
  if (accesscontrol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accesscontrol_;
    accesscontrol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Flow::set_allocated_accesscontrol(::std::string* accesscontrol) {
  if (accesscontrol_ != &::google::protobuf::internal::kEmptyString) {
    delete accesscontrol_;
  }
  if (accesscontrol) {
    set_has_accesscontrol();
    accesscontrol_ = accesscontrol;
  } else {
    clear_has_accesscontrol();
    accesscontrol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 maxCreateFlowRetries = 13;
inline bool Flow::has_maxcreateflowretries() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Flow::set_has_maxcreateflowretries() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Flow::clear_has_maxcreateflowretries() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Flow::clear_maxcreateflowretries() {
  maxcreateflowretries_ = 0u;
  clear_has_maxcreateflowretries();
}
inline ::google::protobuf::uint32 Flow::maxcreateflowretries() const {
  return maxcreateflowretries_;
}
inline void Flow::set_maxcreateflowretries(::google::protobuf::uint32 value) {
  set_has_maxcreateflowretries();
  maxcreateflowretries_ = value;
}

// optional uint32 createFlowRetries = 14;
inline bool Flow::has_createflowretries() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Flow::set_has_createflowretries() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Flow::clear_has_createflowretries() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Flow::clear_createflowretries() {
  createflowretries_ = 0u;
  clear_has_createflowretries();
}
inline ::google::protobuf::uint32 Flow::createflowretries() const {
  return createflowretries_;
}
inline void Flow::set_createflowretries(::google::protobuf::uint32 value) {
  set_has_createflowretries();
  createflowretries_ = value;
}

// optional uint32 hopCount = 15;
inline bool Flow::has_hopcount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Flow::set_has_hopcount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Flow::clear_has_hopcount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Flow::clear_hopcount() {
  hopcount_ = 0u;
  clear_has_hopcount();
}
inline ::google::protobuf::uint32 Flow::hopcount() const {
  return hopcount_;
}
inline void Flow::set_hopcount(::google::protobuf::uint32 value) {
  set_has_hopcount();
  hopcount_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace messages
}  // namespace rina

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FlowMessage_2eproto__INCLUDED
