// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CDAP.proto

#ifndef PROTOBUF_CDAP_2eproto__INCLUDED
#define PROTOBUF_CDAP_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rina {
namespace cdap {
namespace impl {
namespace googleprotobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CDAP_2eproto();
void protobuf_AssignDesc_CDAP_2eproto();
void protobuf_ShutdownFile_CDAP_2eproto();

class objVal_t;
class authValue_t;
class CDAPMessage;

enum opCode_t {
  M_CONNECT = 0,
  M_CONNECT_R = 1,
  M_RELEASE = 2,
  M_RELEASE_R = 3,
  M_CREATE = 4,
  M_CREATE_R = 5,
  M_DELETE = 6,
  M_DELETE_R = 7,
  M_READ = 8,
  M_READ_R = 9,
  M_CANCELREAD = 10,
  M_CANCELREAD_R = 11,
  M_WRITE = 12,
  M_WRITE_R = 13,
  M_START = 14,
  M_START_R = 15,
  M_STOP = 16,
  M_STOP_R = 17
};
bool opCode_t_IsValid(int value);
const opCode_t opCode_t_MIN = M_CONNECT;
const opCode_t opCode_t_MAX = M_STOP_R;
const int opCode_t_ARRAYSIZE = opCode_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* opCode_t_descriptor();
inline const ::std::string& opCode_t_Name(opCode_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    opCode_t_descriptor(), value);
}
inline bool opCode_t_Parse(
    const ::std::string& name, opCode_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<opCode_t>(
    opCode_t_descriptor(), name, value);
}
enum flagValues_t {
  F_NO_FLAGS = 0,
  F_SYNC = 1,
  F_RD_INCOMPLETE = 2
};
bool flagValues_t_IsValid(int value);
const flagValues_t flagValues_t_MIN = F_NO_FLAGS;
const flagValues_t flagValues_t_MAX = F_RD_INCOMPLETE;
const int flagValues_t_ARRAYSIZE = flagValues_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* flagValues_t_descriptor();
inline const ::std::string& flagValues_t_Name(flagValues_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    flagValues_t_descriptor(), value);
}
inline bool flagValues_t_Parse(
    const ::std::string& name, flagValues_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<flagValues_t>(
    flagValues_t_descriptor(), name, value);
}
enum authTypes_t {
  AUTH_NONE = 0,
  AUTH_PASSWD = 1,
  AUTH_SSHRSA = 2,
  AUTH_SSHDSA = 3
};
bool authTypes_t_IsValid(int value);
const authTypes_t authTypes_t_MIN = AUTH_NONE;
const authTypes_t authTypes_t_MAX = AUTH_SSHDSA;
const int authTypes_t_ARRAYSIZE = authTypes_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* authTypes_t_descriptor();
inline const ::std::string& authTypes_t_Name(authTypes_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    authTypes_t_descriptor(), value);
}
inline bool authTypes_t_Parse(
    const ::std::string& name, authTypes_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<authTypes_t>(
    authTypes_t_descriptor(), name, value);
}
// ===================================================================

class objVal_t : public ::google::protobuf::Message {
 public:
  objVal_t();
  virtual ~objVal_t();

  objVal_t(const objVal_t& from);

  inline objVal_t& operator=(const objVal_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const objVal_t& default_instance();

  void Swap(objVal_t* other);

  // implements Message ----------------------------------------------

  objVal_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const objVal_t& from);
  void MergeFrom(const objVal_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 intval = 1;
  inline bool has_intval() const;
  inline void clear_intval();
  static const int kIntvalFieldNumber = 1;
  inline ::google::protobuf::int32 intval() const;
  inline void set_intval(::google::protobuf::int32 value);

  // optional sint32 sintval = 2;
  inline bool has_sintval() const;
  inline void clear_sintval();
  static const int kSintvalFieldNumber = 2;
  inline ::google::protobuf::int32 sintval() const;
  inline void set_sintval(::google::protobuf::int32 value);

  // optional int64 int64val = 3;
  inline bool has_int64val() const;
  inline void clear_int64val();
  static const int kInt64ValFieldNumber = 3;
  inline ::google::protobuf::int64 int64val() const;
  inline void set_int64val(::google::protobuf::int64 value);

  // optional sint64 sint64val = 4;
  inline bool has_sint64val() const;
  inline void clear_sint64val();
  static const int kSint64ValFieldNumber = 4;
  inline ::google::protobuf::int64 sint64val() const;
  inline void set_sint64val(::google::protobuf::int64 value);

  // optional string strval = 5;
  inline bool has_strval() const;
  inline void clear_strval();
  static const int kStrvalFieldNumber = 5;
  inline const ::std::string& strval() const;
  inline void set_strval(const ::std::string& value);
  inline void set_strval(const char* value);
  inline void set_strval(const char* value, size_t size);
  inline ::std::string* mutable_strval();
  inline ::std::string* release_strval();
  inline void set_allocated_strval(::std::string* strval);

  // optional bytes byteval = 6;
  inline bool has_byteval() const;
  inline void clear_byteval();
  static const int kBytevalFieldNumber = 6;
  inline const ::std::string& byteval() const;
  inline void set_byteval(const ::std::string& value);
  inline void set_byteval(const char* value);
  inline void set_byteval(const void* value, size_t size);
  inline ::std::string* mutable_byteval();
  inline ::std::string* release_byteval();
  inline void set_allocated_byteval(::std::string* byteval);

  // optional fixed32 floatval = 7;
  inline bool has_floatval() const;
  inline void clear_floatval();
  static const int kFloatvalFieldNumber = 7;
  inline ::google::protobuf::uint32 floatval() const;
  inline void set_floatval(::google::protobuf::uint32 value);

  // optional fixed64 doubleval = 8;
  inline bool has_doubleval() const;
  inline void clear_doubleval();
  static const int kDoublevalFieldNumber = 8;
  inline ::google::protobuf::uint64 doubleval() const;
  inline void set_doubleval(::google::protobuf::uint64 value);

  // optional bool boolval = 9;
  inline bool has_boolval() const;
  inline void clear_boolval();
  static const int kBoolvalFieldNumber = 9;
  inline bool boolval() const;
  inline void set_boolval(bool value);

  // @@protoc_insertion_point(class_scope:rina.cdap.impl.googleprotobuf.objVal_t)
 private:
  inline void set_has_intval();
  inline void clear_has_intval();
  inline void set_has_sintval();
  inline void clear_has_sintval();
  inline void set_has_int64val();
  inline void clear_has_int64val();
  inline void set_has_sint64val();
  inline void clear_has_sint64val();
  inline void set_has_strval();
  inline void clear_has_strval();
  inline void set_has_byteval();
  inline void clear_has_byteval();
  inline void set_has_floatval();
  inline void clear_has_floatval();
  inline void set_has_doubleval();
  inline void clear_has_doubleval();
  inline void set_has_boolval();
  inline void clear_has_boolval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 intval_;
  ::google::protobuf::int32 sintval_;
  ::google::protobuf::int64 int64val_;
  ::google::protobuf::int64 sint64val_;
  ::std::string* strval_;
  ::std::string* byteval_;
  ::google::protobuf::uint64 doubleval_;
  ::google::protobuf::uint32 floatval_;
  bool boolval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_CDAP_2eproto();
  friend void protobuf_AssignDesc_CDAP_2eproto();
  friend void protobuf_ShutdownFile_CDAP_2eproto();

  void InitAsDefaultInstance();
  static objVal_t* default_instance_;
};
// -------------------------------------------------------------------

class authValue_t : public ::google::protobuf::Message {
 public:
  authValue_t();
  virtual ~authValue_t();

  authValue_t(const authValue_t& from);

  inline authValue_t& operator=(const authValue_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const authValue_t& default_instance();

  void Swap(authValue_t* other);

  // implements Message ----------------------------------------------

  authValue_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const authValue_t& from);
  void MergeFrom(const authValue_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string authName = 1;
  inline bool has_authname() const;
  inline void clear_authname();
  static const int kAuthNameFieldNumber = 1;
  inline const ::std::string& authname() const;
  inline void set_authname(const ::std::string& value);
  inline void set_authname(const char* value);
  inline void set_authname(const char* value, size_t size);
  inline ::std::string* mutable_authname();
  inline ::std::string* release_authname();
  inline void set_allocated_authname(::std::string* authname);

  // optional string authPassword = 2;
  inline bool has_authpassword() const;
  inline void clear_authpassword();
  static const int kAuthPasswordFieldNumber = 2;
  inline const ::std::string& authpassword() const;
  inline void set_authpassword(const ::std::string& value);
  inline void set_authpassword(const char* value);
  inline void set_authpassword(const char* value, size_t size);
  inline ::std::string* mutable_authpassword();
  inline ::std::string* release_authpassword();
  inline void set_allocated_authpassword(::std::string* authpassword);

  // optional bytes authOther = 3;
  inline bool has_authother() const;
  inline void clear_authother();
  static const int kAuthOtherFieldNumber = 3;
  inline const ::std::string& authother() const;
  inline void set_authother(const ::std::string& value);
  inline void set_authother(const char* value);
  inline void set_authother(const void* value, size_t size);
  inline ::std::string* mutable_authother();
  inline ::std::string* release_authother();
  inline void set_allocated_authother(::std::string* authother);

  // @@protoc_insertion_point(class_scope:rina.cdap.impl.googleprotobuf.authValue_t)
 private:
  inline void set_has_authname();
  inline void clear_has_authname();
  inline void set_has_authpassword();
  inline void clear_has_authpassword();
  inline void set_has_authother();
  inline void clear_has_authother();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* authname_;
  ::std::string* authpassword_;
  ::std::string* authother_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CDAP_2eproto();
  friend void protobuf_AssignDesc_CDAP_2eproto();
  friend void protobuf_ShutdownFile_CDAP_2eproto();

  void InitAsDefaultInstance();
  static authValue_t* default_instance_;
};
// -------------------------------------------------------------------

class CDAPMessage : public ::google::protobuf::Message {
 public:
  CDAPMessage();
  virtual ~CDAPMessage();

  CDAPMessage(const CDAPMessage& from);

  inline CDAPMessage& operator=(const CDAPMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDAPMessage& default_instance();

  void Swap(CDAPMessage* other);

  // implements Message ----------------------------------------------

  CDAPMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CDAPMessage& from);
  void MergeFrom(const CDAPMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 absSyntax = 1;
  inline bool has_abssyntax() const;
  inline void clear_abssyntax();
  static const int kAbsSyntaxFieldNumber = 1;
  inline ::google::protobuf::int32 abssyntax() const;
  inline void set_abssyntax(::google::protobuf::int32 value);

  // required .rina.cdap.impl.googleprotobuf.opCode_t opCode = 2;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpCodeFieldNumber = 2;
  inline ::rina::cdap::impl::googleprotobuf::opCode_t opcode() const;
  inline void set_opcode(::rina::cdap::impl::googleprotobuf::opCode_t value);

  // optional int32 invokeID = 3;
  inline bool has_invokeid() const;
  inline void clear_invokeid();
  static const int kInvokeIDFieldNumber = 3;
  inline ::google::protobuf::int32 invokeid() const;
  inline void set_invokeid(::google::protobuf::int32 value);

  // optional .rina.cdap.impl.googleprotobuf.flagValues_t flags = 4;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 4;
  inline ::rina::cdap::impl::googleprotobuf::flagValues_t flags() const;
  inline void set_flags(::rina::cdap::impl::googleprotobuf::flagValues_t value);

  // optional string objClass = 5;
  inline bool has_objclass() const;
  inline void clear_objclass();
  static const int kObjClassFieldNumber = 5;
  inline const ::std::string& objclass() const;
  inline void set_objclass(const ::std::string& value);
  inline void set_objclass(const char* value);
  inline void set_objclass(const char* value, size_t size);
  inline ::std::string* mutable_objclass();
  inline ::std::string* release_objclass();
  inline void set_allocated_objclass(::std::string* objclass);

  // optional string objName = 6;
  inline bool has_objname() const;
  inline void clear_objname();
  static const int kObjNameFieldNumber = 6;
  inline const ::std::string& objname() const;
  inline void set_objname(const ::std::string& value);
  inline void set_objname(const char* value);
  inline void set_objname(const char* value, size_t size);
  inline ::std::string* mutable_objname();
  inline ::std::string* release_objname();
  inline void set_allocated_objname(::std::string* objname);

  // optional int64 objInst = 7;
  inline bool has_objinst() const;
  inline void clear_objinst();
  static const int kObjInstFieldNumber = 7;
  inline ::google::protobuf::int64 objinst() const;
  inline void set_objinst(::google::protobuf::int64 value);

  // optional .rina.cdap.impl.googleprotobuf.objVal_t objValue = 8;
  inline bool has_objvalue() const;
  inline void clear_objvalue();
  static const int kObjValueFieldNumber = 8;
  inline const ::rina::cdap::impl::googleprotobuf::objVal_t& objvalue() const;
  inline ::rina::cdap::impl::googleprotobuf::objVal_t* mutable_objvalue();
  inline ::rina::cdap::impl::googleprotobuf::objVal_t* release_objvalue();
  inline void set_allocated_objvalue(::rina::cdap::impl::googleprotobuf::objVal_t* objvalue);

  // optional int32 result = 9 [default = 0];
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 9;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 scope = 10;
  inline bool has_scope() const;
  inline void clear_scope();
  static const int kScopeFieldNumber = 10;
  inline ::google::protobuf::int32 scope() const;
  inline void set_scope(::google::protobuf::int32 value);

  // optional bytes filter = 11;
  inline bool has_filter() const;
  inline void clear_filter();
  static const int kFilterFieldNumber = 11;
  inline const ::std::string& filter() const;
  inline void set_filter(const ::std::string& value);
  inline void set_filter(const char* value);
  inline void set_filter(const void* value, size_t size);
  inline ::std::string* mutable_filter();
  inline ::std::string* release_filter();
  inline void set_allocated_filter(::std::string* filter);

  // optional .rina.cdap.impl.googleprotobuf.authTypes_t authMech = 17;
  inline bool has_authmech() const;
  inline void clear_authmech();
  static const int kAuthMechFieldNumber = 17;
  inline ::rina::cdap::impl::googleprotobuf::authTypes_t authmech() const;
  inline void set_authmech(::rina::cdap::impl::googleprotobuf::authTypes_t value);

  // optional .rina.cdap.impl.googleprotobuf.authValue_t authValue = 18;
  inline bool has_authvalue() const;
  inline void clear_authvalue();
  static const int kAuthValueFieldNumber = 18;
  inline const ::rina::cdap::impl::googleprotobuf::authValue_t& authvalue() const;
  inline ::rina::cdap::impl::googleprotobuf::authValue_t* mutable_authvalue();
  inline ::rina::cdap::impl::googleprotobuf::authValue_t* release_authvalue();
  inline void set_allocated_authvalue(::rina::cdap::impl::googleprotobuf::authValue_t* authvalue);

  // optional string destAEInst = 19;
  inline bool has_destaeinst() const;
  inline void clear_destaeinst();
  static const int kDestAEInstFieldNumber = 19;
  inline const ::std::string& destaeinst() const;
  inline void set_destaeinst(const ::std::string& value);
  inline void set_destaeinst(const char* value);
  inline void set_destaeinst(const char* value, size_t size);
  inline ::std::string* mutable_destaeinst();
  inline ::std::string* release_destaeinst();
  inline void set_allocated_destaeinst(::std::string* destaeinst);

  // optional string destAEName = 20;
  inline bool has_destaename() const;
  inline void clear_destaename();
  static const int kDestAENameFieldNumber = 20;
  inline const ::std::string& destaename() const;
  inline void set_destaename(const ::std::string& value);
  inline void set_destaename(const char* value);
  inline void set_destaename(const char* value, size_t size);
  inline ::std::string* mutable_destaename();
  inline ::std::string* release_destaename();
  inline void set_allocated_destaename(::std::string* destaename);

  // optional string destApInst = 21;
  inline bool has_destapinst() const;
  inline void clear_destapinst();
  static const int kDestApInstFieldNumber = 21;
  inline const ::std::string& destapinst() const;
  inline void set_destapinst(const ::std::string& value);
  inline void set_destapinst(const char* value);
  inline void set_destapinst(const char* value, size_t size);
  inline ::std::string* mutable_destapinst();
  inline ::std::string* release_destapinst();
  inline void set_allocated_destapinst(::std::string* destapinst);

  // optional string destApName = 22;
  inline bool has_destapname() const;
  inline void clear_destapname();
  static const int kDestApNameFieldNumber = 22;
  inline const ::std::string& destapname() const;
  inline void set_destapname(const ::std::string& value);
  inline void set_destapname(const char* value);
  inline void set_destapname(const char* value, size_t size);
  inline ::std::string* mutable_destapname();
  inline ::std::string* release_destapname();
  inline void set_allocated_destapname(::std::string* destapname);

  // optional string srcAEInst = 23;
  inline bool has_srcaeinst() const;
  inline void clear_srcaeinst();
  static const int kSrcAEInstFieldNumber = 23;
  inline const ::std::string& srcaeinst() const;
  inline void set_srcaeinst(const ::std::string& value);
  inline void set_srcaeinst(const char* value);
  inline void set_srcaeinst(const char* value, size_t size);
  inline ::std::string* mutable_srcaeinst();
  inline ::std::string* release_srcaeinst();
  inline void set_allocated_srcaeinst(::std::string* srcaeinst);

  // optional string srcAEName = 24;
  inline bool has_srcaename() const;
  inline void clear_srcaename();
  static const int kSrcAENameFieldNumber = 24;
  inline const ::std::string& srcaename() const;
  inline void set_srcaename(const ::std::string& value);
  inline void set_srcaename(const char* value);
  inline void set_srcaename(const char* value, size_t size);
  inline ::std::string* mutable_srcaename();
  inline ::std::string* release_srcaename();
  inline void set_allocated_srcaename(::std::string* srcaename);

  // optional string srcApInst = 25;
  inline bool has_srcapinst() const;
  inline void clear_srcapinst();
  static const int kSrcApInstFieldNumber = 25;
  inline const ::std::string& srcapinst() const;
  inline void set_srcapinst(const ::std::string& value);
  inline void set_srcapinst(const char* value);
  inline void set_srcapinst(const char* value, size_t size);
  inline ::std::string* mutable_srcapinst();
  inline ::std::string* release_srcapinst();
  inline void set_allocated_srcapinst(::std::string* srcapinst);

  // optional string srcApName = 26;
  inline bool has_srcapname() const;
  inline void clear_srcapname();
  static const int kSrcApNameFieldNumber = 26;
  inline const ::std::string& srcapname() const;
  inline void set_srcapname(const ::std::string& value);
  inline void set_srcapname(const char* value);
  inline void set_srcapname(const char* value, size_t size);
  inline ::std::string* mutable_srcapname();
  inline ::std::string* release_srcapname();
  inline void set_allocated_srcapname(::std::string* srcapname);

  // optional string resultReason = 27;
  inline bool has_resultreason() const;
  inline void clear_resultreason();
  static const int kResultReasonFieldNumber = 27;
  inline const ::std::string& resultreason() const;
  inline void set_resultreason(const ::std::string& value);
  inline void set_resultreason(const char* value);
  inline void set_resultreason(const char* value, size_t size);
  inline ::std::string* mutable_resultreason();
  inline ::std::string* release_resultreason();
  inline void set_allocated_resultreason(::std::string* resultreason);

  // optional int64 version = 28;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 28;
  inline ::google::protobuf::int64 version() const;
  inline void set_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:rina.cdap.impl.googleprotobuf.CDAPMessage)
 private:
  inline void set_has_abssyntax();
  inline void clear_has_abssyntax();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_invokeid();
  inline void clear_has_invokeid();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_objclass();
  inline void clear_has_objclass();
  inline void set_has_objname();
  inline void clear_has_objname();
  inline void set_has_objinst();
  inline void clear_has_objinst();
  inline void set_has_objvalue();
  inline void clear_has_objvalue();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_scope();
  inline void clear_has_scope();
  inline void set_has_filter();
  inline void clear_has_filter();
  inline void set_has_authmech();
  inline void clear_has_authmech();
  inline void set_has_authvalue();
  inline void clear_has_authvalue();
  inline void set_has_destaeinst();
  inline void clear_has_destaeinst();
  inline void set_has_destaename();
  inline void clear_has_destaename();
  inline void set_has_destapinst();
  inline void clear_has_destapinst();
  inline void set_has_destapname();
  inline void clear_has_destapname();
  inline void set_has_srcaeinst();
  inline void clear_has_srcaeinst();
  inline void set_has_srcaename();
  inline void clear_has_srcaename();
  inline void set_has_srcapinst();
  inline void clear_has_srcapinst();
  inline void set_has_srcapname();
  inline void clear_has_srcapname();
  inline void set_has_resultreason();
  inline void clear_has_resultreason();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 abssyntax_;
  int opcode_;
  ::google::protobuf::int32 invokeid_;
  int flags_;
  ::std::string* objclass_;
  ::std::string* objname_;
  ::google::protobuf::int64 objinst_;
  ::rina::cdap::impl::googleprotobuf::objVal_t* objvalue_;
  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 scope_;
  ::std::string* filter_;
  ::rina::cdap::impl::googleprotobuf::authValue_t* authvalue_;
  ::std::string* destaeinst_;
  ::std::string* destaename_;
  ::std::string* destapinst_;
  ::std::string* destapname_;
  ::std::string* srcaeinst_;
  ::std::string* srcaename_;
  ::std::string* srcapinst_;
  ::std::string* srcapname_;
  ::std::string* resultreason_;
  ::google::protobuf::int64 version_;
  int authmech_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_CDAP_2eproto();
  friend void protobuf_AssignDesc_CDAP_2eproto();
  friend void protobuf_ShutdownFile_CDAP_2eproto();

  void InitAsDefaultInstance();
  static CDAPMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// objVal_t

// optional int32 intval = 1;
inline bool objVal_t::has_intval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void objVal_t::set_has_intval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void objVal_t::clear_has_intval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void objVal_t::clear_intval() {
  intval_ = 0;
  clear_has_intval();
}
inline ::google::protobuf::int32 objVal_t::intval() const {
  return intval_;
}
inline void objVal_t::set_intval(::google::protobuf::int32 value) {
  set_has_intval();
  intval_ = value;
}

// optional sint32 sintval = 2;
inline bool objVal_t::has_sintval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void objVal_t::set_has_sintval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void objVal_t::clear_has_sintval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void objVal_t::clear_sintval() {
  sintval_ = 0;
  clear_has_sintval();
}
inline ::google::protobuf::int32 objVal_t::sintval() const {
  return sintval_;
}
inline void objVal_t::set_sintval(::google::protobuf::int32 value) {
  set_has_sintval();
  sintval_ = value;
}

// optional int64 int64val = 3;
inline bool objVal_t::has_int64val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void objVal_t::set_has_int64val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void objVal_t::clear_has_int64val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void objVal_t::clear_int64val() {
  int64val_ = GOOGLE_LONGLONG(0);
  clear_has_int64val();
}
inline ::google::protobuf::int64 objVal_t::int64val() const {
  return int64val_;
}
inline void objVal_t::set_int64val(::google::protobuf::int64 value) {
  set_has_int64val();
  int64val_ = value;
}

// optional sint64 sint64val = 4;
inline bool objVal_t::has_sint64val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void objVal_t::set_has_sint64val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void objVal_t::clear_has_sint64val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void objVal_t::clear_sint64val() {
  sint64val_ = GOOGLE_LONGLONG(0);
  clear_has_sint64val();
}
inline ::google::protobuf::int64 objVal_t::sint64val() const {
  return sint64val_;
}
inline void objVal_t::set_sint64val(::google::protobuf::int64 value) {
  set_has_sint64val();
  sint64val_ = value;
}

// optional string strval = 5;
inline bool objVal_t::has_strval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void objVal_t::set_has_strval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void objVal_t::clear_has_strval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void objVal_t::clear_strval() {
  if (strval_ != &::google::protobuf::internal::kEmptyString) {
    strval_->clear();
  }
  clear_has_strval();
}
inline const ::std::string& objVal_t::strval() const {
  return *strval_;
}
inline void objVal_t::set_strval(const ::std::string& value) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::kEmptyString) {
    strval_ = new ::std::string;
  }
  strval_->assign(value);
}
inline void objVal_t::set_strval(const char* value) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::kEmptyString) {
    strval_ = new ::std::string;
  }
  strval_->assign(value);
}
inline void objVal_t::set_strval(const char* value, size_t size) {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::kEmptyString) {
    strval_ = new ::std::string;
  }
  strval_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* objVal_t::mutable_strval() {
  set_has_strval();
  if (strval_ == &::google::protobuf::internal::kEmptyString) {
    strval_ = new ::std::string;
  }
  return strval_;
}
inline ::std::string* objVal_t::release_strval() {
  clear_has_strval();
  if (strval_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strval_;
    strval_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void objVal_t::set_allocated_strval(::std::string* strval) {
  if (strval_ != &::google::protobuf::internal::kEmptyString) {
    delete strval_;
  }
  if (strval) {
    set_has_strval();
    strval_ = strval;
  } else {
    clear_has_strval();
    strval_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes byteval = 6;
inline bool objVal_t::has_byteval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void objVal_t::set_has_byteval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void objVal_t::clear_has_byteval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void objVal_t::clear_byteval() {
  if (byteval_ != &::google::protobuf::internal::kEmptyString) {
    byteval_->clear();
  }
  clear_has_byteval();
}
inline const ::std::string& objVal_t::byteval() const {
  return *byteval_;
}
inline void objVal_t::set_byteval(const ::std::string& value) {
  set_has_byteval();
  if (byteval_ == &::google::protobuf::internal::kEmptyString) {
    byteval_ = new ::std::string;
  }
  byteval_->assign(value);
}
inline void objVal_t::set_byteval(const char* value) {
  set_has_byteval();
  if (byteval_ == &::google::protobuf::internal::kEmptyString) {
    byteval_ = new ::std::string;
  }
  byteval_->assign(value);
}
inline void objVal_t::set_byteval(const void* value, size_t size) {
  set_has_byteval();
  if (byteval_ == &::google::protobuf::internal::kEmptyString) {
    byteval_ = new ::std::string;
  }
  byteval_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* objVal_t::mutable_byteval() {
  set_has_byteval();
  if (byteval_ == &::google::protobuf::internal::kEmptyString) {
    byteval_ = new ::std::string;
  }
  return byteval_;
}
inline ::std::string* objVal_t::release_byteval() {
  clear_has_byteval();
  if (byteval_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = byteval_;
    byteval_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void objVal_t::set_allocated_byteval(::std::string* byteval) {
  if (byteval_ != &::google::protobuf::internal::kEmptyString) {
    delete byteval_;
  }
  if (byteval) {
    set_has_byteval();
    byteval_ = byteval;
  } else {
    clear_has_byteval();
    byteval_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 floatval = 7;
inline bool objVal_t::has_floatval() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void objVal_t::set_has_floatval() {
  _has_bits_[0] |= 0x00000040u;
}
inline void objVal_t::clear_has_floatval() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void objVal_t::clear_floatval() {
  floatval_ = 0u;
  clear_has_floatval();
}
inline ::google::protobuf::uint32 objVal_t::floatval() const {
  return floatval_;
}
inline void objVal_t::set_floatval(::google::protobuf::uint32 value) {
  set_has_floatval();
  floatval_ = value;
}

// optional fixed64 doubleval = 8;
inline bool objVal_t::has_doubleval() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void objVal_t::set_has_doubleval() {
  _has_bits_[0] |= 0x00000080u;
}
inline void objVal_t::clear_has_doubleval() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void objVal_t::clear_doubleval() {
  doubleval_ = GOOGLE_ULONGLONG(0);
  clear_has_doubleval();
}
inline ::google::protobuf::uint64 objVal_t::doubleval() const {
  return doubleval_;
}
inline void objVal_t::set_doubleval(::google::protobuf::uint64 value) {
  set_has_doubleval();
  doubleval_ = value;
}

// optional bool boolval = 9;
inline bool objVal_t::has_boolval() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void objVal_t::set_has_boolval() {
  _has_bits_[0] |= 0x00000100u;
}
inline void objVal_t::clear_has_boolval() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void objVal_t::clear_boolval() {
  boolval_ = false;
  clear_has_boolval();
}
inline bool objVal_t::boolval() const {
  return boolval_;
}
inline void objVal_t::set_boolval(bool value) {
  set_has_boolval();
  boolval_ = value;
}

// -------------------------------------------------------------------

// authValue_t

// optional string authName = 1;
inline bool authValue_t::has_authname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void authValue_t::set_has_authname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void authValue_t::clear_has_authname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void authValue_t::clear_authname() {
  if (authname_ != &::google::protobuf::internal::kEmptyString) {
    authname_->clear();
  }
  clear_has_authname();
}
inline const ::std::string& authValue_t::authname() const {
  return *authname_;
}
inline void authValue_t::set_authname(const ::std::string& value) {
  set_has_authname();
  if (authname_ == &::google::protobuf::internal::kEmptyString) {
    authname_ = new ::std::string;
  }
  authname_->assign(value);
}
inline void authValue_t::set_authname(const char* value) {
  set_has_authname();
  if (authname_ == &::google::protobuf::internal::kEmptyString) {
    authname_ = new ::std::string;
  }
  authname_->assign(value);
}
inline void authValue_t::set_authname(const char* value, size_t size) {
  set_has_authname();
  if (authname_ == &::google::protobuf::internal::kEmptyString) {
    authname_ = new ::std::string;
  }
  authname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* authValue_t::mutable_authname() {
  set_has_authname();
  if (authname_ == &::google::protobuf::internal::kEmptyString) {
    authname_ = new ::std::string;
  }
  return authname_;
}
inline ::std::string* authValue_t::release_authname() {
  clear_has_authname();
  if (authname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authname_;
    authname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void authValue_t::set_allocated_authname(::std::string* authname) {
  if (authname_ != &::google::protobuf::internal::kEmptyString) {
    delete authname_;
  }
  if (authname) {
    set_has_authname();
    authname_ = authname;
  } else {
    clear_has_authname();
    authname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string authPassword = 2;
inline bool authValue_t::has_authpassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void authValue_t::set_has_authpassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void authValue_t::clear_has_authpassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void authValue_t::clear_authpassword() {
  if (authpassword_ != &::google::protobuf::internal::kEmptyString) {
    authpassword_->clear();
  }
  clear_has_authpassword();
}
inline const ::std::string& authValue_t::authpassword() const {
  return *authpassword_;
}
inline void authValue_t::set_authpassword(const ::std::string& value) {
  set_has_authpassword();
  if (authpassword_ == &::google::protobuf::internal::kEmptyString) {
    authpassword_ = new ::std::string;
  }
  authpassword_->assign(value);
}
inline void authValue_t::set_authpassword(const char* value) {
  set_has_authpassword();
  if (authpassword_ == &::google::protobuf::internal::kEmptyString) {
    authpassword_ = new ::std::string;
  }
  authpassword_->assign(value);
}
inline void authValue_t::set_authpassword(const char* value, size_t size) {
  set_has_authpassword();
  if (authpassword_ == &::google::protobuf::internal::kEmptyString) {
    authpassword_ = new ::std::string;
  }
  authpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* authValue_t::mutable_authpassword() {
  set_has_authpassword();
  if (authpassword_ == &::google::protobuf::internal::kEmptyString) {
    authpassword_ = new ::std::string;
  }
  return authpassword_;
}
inline ::std::string* authValue_t::release_authpassword() {
  clear_has_authpassword();
  if (authpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authpassword_;
    authpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void authValue_t::set_allocated_authpassword(::std::string* authpassword) {
  if (authpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete authpassword_;
  }
  if (authpassword) {
    set_has_authpassword();
    authpassword_ = authpassword;
  } else {
    clear_has_authpassword();
    authpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes authOther = 3;
inline bool authValue_t::has_authother() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void authValue_t::set_has_authother() {
  _has_bits_[0] |= 0x00000004u;
}
inline void authValue_t::clear_has_authother() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void authValue_t::clear_authother() {
  if (authother_ != &::google::protobuf::internal::kEmptyString) {
    authother_->clear();
  }
  clear_has_authother();
}
inline const ::std::string& authValue_t::authother() const {
  return *authother_;
}
inline void authValue_t::set_authother(const ::std::string& value) {
  set_has_authother();
  if (authother_ == &::google::protobuf::internal::kEmptyString) {
    authother_ = new ::std::string;
  }
  authother_->assign(value);
}
inline void authValue_t::set_authother(const char* value) {
  set_has_authother();
  if (authother_ == &::google::protobuf::internal::kEmptyString) {
    authother_ = new ::std::string;
  }
  authother_->assign(value);
}
inline void authValue_t::set_authother(const void* value, size_t size) {
  set_has_authother();
  if (authother_ == &::google::protobuf::internal::kEmptyString) {
    authother_ = new ::std::string;
  }
  authother_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* authValue_t::mutable_authother() {
  set_has_authother();
  if (authother_ == &::google::protobuf::internal::kEmptyString) {
    authother_ = new ::std::string;
  }
  return authother_;
}
inline ::std::string* authValue_t::release_authother() {
  clear_has_authother();
  if (authother_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authother_;
    authother_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void authValue_t::set_allocated_authother(::std::string* authother) {
  if (authother_ != &::google::protobuf::internal::kEmptyString) {
    delete authother_;
  }
  if (authother) {
    set_has_authother();
    authother_ = authother;
  } else {
    clear_has_authother();
    authother_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CDAPMessage

// optional int32 absSyntax = 1;
inline bool CDAPMessage::has_abssyntax() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CDAPMessage::set_has_abssyntax() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CDAPMessage::clear_has_abssyntax() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CDAPMessage::clear_abssyntax() {
  abssyntax_ = 0;
  clear_has_abssyntax();
}
inline ::google::protobuf::int32 CDAPMessage::abssyntax() const {
  return abssyntax_;
}
inline void CDAPMessage::set_abssyntax(::google::protobuf::int32 value) {
  set_has_abssyntax();
  abssyntax_ = value;
}

// required .rina.cdap.impl.googleprotobuf.opCode_t opCode = 2;
inline bool CDAPMessage::has_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CDAPMessage::set_has_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CDAPMessage::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CDAPMessage::clear_opcode() {
  opcode_ = 0;
  clear_has_opcode();
}
inline ::rina::cdap::impl::googleprotobuf::opCode_t CDAPMessage::opcode() const {
  return static_cast< ::rina::cdap::impl::googleprotobuf::opCode_t >(opcode_);
}
inline void CDAPMessage::set_opcode(::rina::cdap::impl::googleprotobuf::opCode_t value) {
  assert(::rina::cdap::impl::googleprotobuf::opCode_t_IsValid(value));
  set_has_opcode();
  opcode_ = value;
}

// optional int32 invokeID = 3;
inline bool CDAPMessage::has_invokeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CDAPMessage::set_has_invokeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CDAPMessage::clear_has_invokeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CDAPMessage::clear_invokeid() {
  invokeid_ = 0;
  clear_has_invokeid();
}
inline ::google::protobuf::int32 CDAPMessage::invokeid() const {
  return invokeid_;
}
inline void CDAPMessage::set_invokeid(::google::protobuf::int32 value) {
  set_has_invokeid();
  invokeid_ = value;
}

// optional .rina.cdap.impl.googleprotobuf.flagValues_t flags = 4;
inline bool CDAPMessage::has_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CDAPMessage::set_has_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CDAPMessage::clear_has_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CDAPMessage::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::rina::cdap::impl::googleprotobuf::flagValues_t CDAPMessage::flags() const {
  return static_cast< ::rina::cdap::impl::googleprotobuf::flagValues_t >(flags_);
}
inline void CDAPMessage::set_flags(::rina::cdap::impl::googleprotobuf::flagValues_t value) {
  assert(::rina::cdap::impl::googleprotobuf::flagValues_t_IsValid(value));
  set_has_flags();
  flags_ = value;
}

// optional string objClass = 5;
inline bool CDAPMessage::has_objclass() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CDAPMessage::set_has_objclass() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CDAPMessage::clear_has_objclass() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CDAPMessage::clear_objclass() {
  if (objclass_ != &::google::protobuf::internal::kEmptyString) {
    objclass_->clear();
  }
  clear_has_objclass();
}
inline const ::std::string& CDAPMessage::objclass() const {
  return *objclass_;
}
inline void CDAPMessage::set_objclass(const ::std::string& value) {
  set_has_objclass();
  if (objclass_ == &::google::protobuf::internal::kEmptyString) {
    objclass_ = new ::std::string;
  }
  objclass_->assign(value);
}
inline void CDAPMessage::set_objclass(const char* value) {
  set_has_objclass();
  if (objclass_ == &::google::protobuf::internal::kEmptyString) {
    objclass_ = new ::std::string;
  }
  objclass_->assign(value);
}
inline void CDAPMessage::set_objclass(const char* value, size_t size) {
  set_has_objclass();
  if (objclass_ == &::google::protobuf::internal::kEmptyString) {
    objclass_ = new ::std::string;
  }
  objclass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_objclass() {
  set_has_objclass();
  if (objclass_ == &::google::protobuf::internal::kEmptyString) {
    objclass_ = new ::std::string;
  }
  return objclass_;
}
inline ::std::string* CDAPMessage::release_objclass() {
  clear_has_objclass();
  if (objclass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objclass_;
    objclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_objclass(::std::string* objclass) {
  if (objclass_ != &::google::protobuf::internal::kEmptyString) {
    delete objclass_;
  }
  if (objclass) {
    set_has_objclass();
    objclass_ = objclass;
  } else {
    clear_has_objclass();
    objclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string objName = 6;
inline bool CDAPMessage::has_objname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CDAPMessage::set_has_objname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CDAPMessage::clear_has_objname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CDAPMessage::clear_objname() {
  if (objname_ != &::google::protobuf::internal::kEmptyString) {
    objname_->clear();
  }
  clear_has_objname();
}
inline const ::std::string& CDAPMessage::objname() const {
  return *objname_;
}
inline void CDAPMessage::set_objname(const ::std::string& value) {
  set_has_objname();
  if (objname_ == &::google::protobuf::internal::kEmptyString) {
    objname_ = new ::std::string;
  }
  objname_->assign(value);
}
inline void CDAPMessage::set_objname(const char* value) {
  set_has_objname();
  if (objname_ == &::google::protobuf::internal::kEmptyString) {
    objname_ = new ::std::string;
  }
  objname_->assign(value);
}
inline void CDAPMessage::set_objname(const char* value, size_t size) {
  set_has_objname();
  if (objname_ == &::google::protobuf::internal::kEmptyString) {
    objname_ = new ::std::string;
  }
  objname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_objname() {
  set_has_objname();
  if (objname_ == &::google::protobuf::internal::kEmptyString) {
    objname_ = new ::std::string;
  }
  return objname_;
}
inline ::std::string* CDAPMessage::release_objname() {
  clear_has_objname();
  if (objname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = objname_;
    objname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_objname(::std::string* objname) {
  if (objname_ != &::google::protobuf::internal::kEmptyString) {
    delete objname_;
  }
  if (objname) {
    set_has_objname();
    objname_ = objname;
  } else {
    clear_has_objname();
    objname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 objInst = 7;
inline bool CDAPMessage::has_objinst() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CDAPMessage::set_has_objinst() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CDAPMessage::clear_has_objinst() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CDAPMessage::clear_objinst() {
  objinst_ = GOOGLE_LONGLONG(0);
  clear_has_objinst();
}
inline ::google::protobuf::int64 CDAPMessage::objinst() const {
  return objinst_;
}
inline void CDAPMessage::set_objinst(::google::protobuf::int64 value) {
  set_has_objinst();
  objinst_ = value;
}

// optional .rina.cdap.impl.googleprotobuf.objVal_t objValue = 8;
inline bool CDAPMessage::has_objvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CDAPMessage::set_has_objvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CDAPMessage::clear_has_objvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CDAPMessage::clear_objvalue() {
  if (objvalue_ != NULL) objvalue_->::rina::cdap::impl::googleprotobuf::objVal_t::Clear();
  clear_has_objvalue();
}
inline const ::rina::cdap::impl::googleprotobuf::objVal_t& CDAPMessage::objvalue() const {
  return objvalue_ != NULL ? *objvalue_ : *default_instance_->objvalue_;
}
inline ::rina::cdap::impl::googleprotobuf::objVal_t* CDAPMessage::mutable_objvalue() {
  set_has_objvalue();
  if (objvalue_ == NULL) objvalue_ = new ::rina::cdap::impl::googleprotobuf::objVal_t;
  return objvalue_;
}
inline ::rina::cdap::impl::googleprotobuf::objVal_t* CDAPMessage::release_objvalue() {
  clear_has_objvalue();
  ::rina::cdap::impl::googleprotobuf::objVal_t* temp = objvalue_;
  objvalue_ = NULL;
  return temp;
}
inline void CDAPMessage::set_allocated_objvalue(::rina::cdap::impl::googleprotobuf::objVal_t* objvalue) {
  delete objvalue_;
  objvalue_ = objvalue;
  if (objvalue) {
    set_has_objvalue();
  } else {
    clear_has_objvalue();
  }
}

// optional int32 result = 9 [default = 0];
inline bool CDAPMessage::has_result() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CDAPMessage::set_has_result() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CDAPMessage::clear_has_result() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CDAPMessage::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 CDAPMessage::result() const {
  return result_;
}
inline void CDAPMessage::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 scope = 10;
inline bool CDAPMessage::has_scope() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CDAPMessage::set_has_scope() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CDAPMessage::clear_has_scope() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CDAPMessage::clear_scope() {
  scope_ = 0;
  clear_has_scope();
}
inline ::google::protobuf::int32 CDAPMessage::scope() const {
  return scope_;
}
inline void CDAPMessage::set_scope(::google::protobuf::int32 value) {
  set_has_scope();
  scope_ = value;
}

// optional bytes filter = 11;
inline bool CDAPMessage::has_filter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CDAPMessage::set_has_filter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CDAPMessage::clear_has_filter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CDAPMessage::clear_filter() {
  if (filter_ != &::google::protobuf::internal::kEmptyString) {
    filter_->clear();
  }
  clear_has_filter();
}
inline const ::std::string& CDAPMessage::filter() const {
  return *filter_;
}
inline void CDAPMessage::set_filter(const ::std::string& value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void CDAPMessage::set_filter(const char* value) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(value);
}
inline void CDAPMessage::set_filter(const void* value, size_t size) {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  filter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_filter() {
  set_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    filter_ = new ::std::string;
  }
  return filter_;
}
inline ::std::string* CDAPMessage::release_filter() {
  clear_has_filter();
  if (filter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_;
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_filter(::std::string* filter) {
  if (filter_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_;
  }
  if (filter) {
    set_has_filter();
    filter_ = filter;
  } else {
    clear_has_filter();
    filter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .rina.cdap.impl.googleprotobuf.authTypes_t authMech = 17;
inline bool CDAPMessage::has_authmech() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CDAPMessage::set_has_authmech() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CDAPMessage::clear_has_authmech() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CDAPMessage::clear_authmech() {
  authmech_ = 0;
  clear_has_authmech();
}
inline ::rina::cdap::impl::googleprotobuf::authTypes_t CDAPMessage::authmech() const {
  return static_cast< ::rina::cdap::impl::googleprotobuf::authTypes_t >(authmech_);
}
inline void CDAPMessage::set_authmech(::rina::cdap::impl::googleprotobuf::authTypes_t value) {
  assert(::rina::cdap::impl::googleprotobuf::authTypes_t_IsValid(value));
  set_has_authmech();
  authmech_ = value;
}

// optional .rina.cdap.impl.googleprotobuf.authValue_t authValue = 18;
inline bool CDAPMessage::has_authvalue() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CDAPMessage::set_has_authvalue() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CDAPMessage::clear_has_authvalue() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CDAPMessage::clear_authvalue() {
  if (authvalue_ != NULL) authvalue_->::rina::cdap::impl::googleprotobuf::authValue_t::Clear();
  clear_has_authvalue();
}
inline const ::rina::cdap::impl::googleprotobuf::authValue_t& CDAPMessage::authvalue() const {
  return authvalue_ != NULL ? *authvalue_ : *default_instance_->authvalue_;
}
inline ::rina::cdap::impl::googleprotobuf::authValue_t* CDAPMessage::mutable_authvalue() {
  set_has_authvalue();
  if (authvalue_ == NULL) authvalue_ = new ::rina::cdap::impl::googleprotobuf::authValue_t;
  return authvalue_;
}
inline ::rina::cdap::impl::googleprotobuf::authValue_t* CDAPMessage::release_authvalue() {
  clear_has_authvalue();
  ::rina::cdap::impl::googleprotobuf::authValue_t* temp = authvalue_;
  authvalue_ = NULL;
  return temp;
}
inline void CDAPMessage::set_allocated_authvalue(::rina::cdap::impl::googleprotobuf::authValue_t* authvalue) {
  delete authvalue_;
  authvalue_ = authvalue;
  if (authvalue) {
    set_has_authvalue();
  } else {
    clear_has_authvalue();
  }
}

// optional string destAEInst = 19;
inline bool CDAPMessage::has_destaeinst() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CDAPMessage::set_has_destaeinst() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CDAPMessage::clear_has_destaeinst() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CDAPMessage::clear_destaeinst() {
  if (destaeinst_ != &::google::protobuf::internal::kEmptyString) {
    destaeinst_->clear();
  }
  clear_has_destaeinst();
}
inline const ::std::string& CDAPMessage::destaeinst() const {
  return *destaeinst_;
}
inline void CDAPMessage::set_destaeinst(const ::std::string& value) {
  set_has_destaeinst();
  if (destaeinst_ == &::google::protobuf::internal::kEmptyString) {
    destaeinst_ = new ::std::string;
  }
  destaeinst_->assign(value);
}
inline void CDAPMessage::set_destaeinst(const char* value) {
  set_has_destaeinst();
  if (destaeinst_ == &::google::protobuf::internal::kEmptyString) {
    destaeinst_ = new ::std::string;
  }
  destaeinst_->assign(value);
}
inline void CDAPMessage::set_destaeinst(const char* value, size_t size) {
  set_has_destaeinst();
  if (destaeinst_ == &::google::protobuf::internal::kEmptyString) {
    destaeinst_ = new ::std::string;
  }
  destaeinst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_destaeinst() {
  set_has_destaeinst();
  if (destaeinst_ == &::google::protobuf::internal::kEmptyString) {
    destaeinst_ = new ::std::string;
  }
  return destaeinst_;
}
inline ::std::string* CDAPMessage::release_destaeinst() {
  clear_has_destaeinst();
  if (destaeinst_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destaeinst_;
    destaeinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_destaeinst(::std::string* destaeinst) {
  if (destaeinst_ != &::google::protobuf::internal::kEmptyString) {
    delete destaeinst_;
  }
  if (destaeinst) {
    set_has_destaeinst();
    destaeinst_ = destaeinst;
  } else {
    clear_has_destaeinst();
    destaeinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string destAEName = 20;
inline bool CDAPMessage::has_destaename() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CDAPMessage::set_has_destaename() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CDAPMessage::clear_has_destaename() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CDAPMessage::clear_destaename() {
  if (destaename_ != &::google::protobuf::internal::kEmptyString) {
    destaename_->clear();
  }
  clear_has_destaename();
}
inline const ::std::string& CDAPMessage::destaename() const {
  return *destaename_;
}
inline void CDAPMessage::set_destaename(const ::std::string& value) {
  set_has_destaename();
  if (destaename_ == &::google::protobuf::internal::kEmptyString) {
    destaename_ = new ::std::string;
  }
  destaename_->assign(value);
}
inline void CDAPMessage::set_destaename(const char* value) {
  set_has_destaename();
  if (destaename_ == &::google::protobuf::internal::kEmptyString) {
    destaename_ = new ::std::string;
  }
  destaename_->assign(value);
}
inline void CDAPMessage::set_destaename(const char* value, size_t size) {
  set_has_destaename();
  if (destaename_ == &::google::protobuf::internal::kEmptyString) {
    destaename_ = new ::std::string;
  }
  destaename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_destaename() {
  set_has_destaename();
  if (destaename_ == &::google::protobuf::internal::kEmptyString) {
    destaename_ = new ::std::string;
  }
  return destaename_;
}
inline ::std::string* CDAPMessage::release_destaename() {
  clear_has_destaename();
  if (destaename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destaename_;
    destaename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_destaename(::std::string* destaename) {
  if (destaename_ != &::google::protobuf::internal::kEmptyString) {
    delete destaename_;
  }
  if (destaename) {
    set_has_destaename();
    destaename_ = destaename;
  } else {
    clear_has_destaename();
    destaename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string destApInst = 21;
inline bool CDAPMessage::has_destapinst() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CDAPMessage::set_has_destapinst() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CDAPMessage::clear_has_destapinst() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CDAPMessage::clear_destapinst() {
  if (destapinst_ != &::google::protobuf::internal::kEmptyString) {
    destapinst_->clear();
  }
  clear_has_destapinst();
}
inline const ::std::string& CDAPMessage::destapinst() const {
  return *destapinst_;
}
inline void CDAPMessage::set_destapinst(const ::std::string& value) {
  set_has_destapinst();
  if (destapinst_ == &::google::protobuf::internal::kEmptyString) {
    destapinst_ = new ::std::string;
  }
  destapinst_->assign(value);
}
inline void CDAPMessage::set_destapinst(const char* value) {
  set_has_destapinst();
  if (destapinst_ == &::google::protobuf::internal::kEmptyString) {
    destapinst_ = new ::std::string;
  }
  destapinst_->assign(value);
}
inline void CDAPMessage::set_destapinst(const char* value, size_t size) {
  set_has_destapinst();
  if (destapinst_ == &::google::protobuf::internal::kEmptyString) {
    destapinst_ = new ::std::string;
  }
  destapinst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_destapinst() {
  set_has_destapinst();
  if (destapinst_ == &::google::protobuf::internal::kEmptyString) {
    destapinst_ = new ::std::string;
  }
  return destapinst_;
}
inline ::std::string* CDAPMessage::release_destapinst() {
  clear_has_destapinst();
  if (destapinst_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destapinst_;
    destapinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_destapinst(::std::string* destapinst) {
  if (destapinst_ != &::google::protobuf::internal::kEmptyString) {
    delete destapinst_;
  }
  if (destapinst) {
    set_has_destapinst();
    destapinst_ = destapinst;
  } else {
    clear_has_destapinst();
    destapinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string destApName = 22;
inline bool CDAPMessage::has_destapname() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CDAPMessage::set_has_destapname() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CDAPMessage::clear_has_destapname() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CDAPMessage::clear_destapname() {
  if (destapname_ != &::google::protobuf::internal::kEmptyString) {
    destapname_->clear();
  }
  clear_has_destapname();
}
inline const ::std::string& CDAPMessage::destapname() const {
  return *destapname_;
}
inline void CDAPMessage::set_destapname(const ::std::string& value) {
  set_has_destapname();
  if (destapname_ == &::google::protobuf::internal::kEmptyString) {
    destapname_ = new ::std::string;
  }
  destapname_->assign(value);
}
inline void CDAPMessage::set_destapname(const char* value) {
  set_has_destapname();
  if (destapname_ == &::google::protobuf::internal::kEmptyString) {
    destapname_ = new ::std::string;
  }
  destapname_->assign(value);
}
inline void CDAPMessage::set_destapname(const char* value, size_t size) {
  set_has_destapname();
  if (destapname_ == &::google::protobuf::internal::kEmptyString) {
    destapname_ = new ::std::string;
  }
  destapname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_destapname() {
  set_has_destapname();
  if (destapname_ == &::google::protobuf::internal::kEmptyString) {
    destapname_ = new ::std::string;
  }
  return destapname_;
}
inline ::std::string* CDAPMessage::release_destapname() {
  clear_has_destapname();
  if (destapname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = destapname_;
    destapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_destapname(::std::string* destapname) {
  if (destapname_ != &::google::protobuf::internal::kEmptyString) {
    delete destapname_;
  }
  if (destapname) {
    set_has_destapname();
    destapname_ = destapname;
  } else {
    clear_has_destapname();
    destapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srcAEInst = 23;
inline bool CDAPMessage::has_srcaeinst() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CDAPMessage::set_has_srcaeinst() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CDAPMessage::clear_has_srcaeinst() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CDAPMessage::clear_srcaeinst() {
  if (srcaeinst_ != &::google::protobuf::internal::kEmptyString) {
    srcaeinst_->clear();
  }
  clear_has_srcaeinst();
}
inline const ::std::string& CDAPMessage::srcaeinst() const {
  return *srcaeinst_;
}
inline void CDAPMessage::set_srcaeinst(const ::std::string& value) {
  set_has_srcaeinst();
  if (srcaeinst_ == &::google::protobuf::internal::kEmptyString) {
    srcaeinst_ = new ::std::string;
  }
  srcaeinst_->assign(value);
}
inline void CDAPMessage::set_srcaeinst(const char* value) {
  set_has_srcaeinst();
  if (srcaeinst_ == &::google::protobuf::internal::kEmptyString) {
    srcaeinst_ = new ::std::string;
  }
  srcaeinst_->assign(value);
}
inline void CDAPMessage::set_srcaeinst(const char* value, size_t size) {
  set_has_srcaeinst();
  if (srcaeinst_ == &::google::protobuf::internal::kEmptyString) {
    srcaeinst_ = new ::std::string;
  }
  srcaeinst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_srcaeinst() {
  set_has_srcaeinst();
  if (srcaeinst_ == &::google::protobuf::internal::kEmptyString) {
    srcaeinst_ = new ::std::string;
  }
  return srcaeinst_;
}
inline ::std::string* CDAPMessage::release_srcaeinst() {
  clear_has_srcaeinst();
  if (srcaeinst_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcaeinst_;
    srcaeinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_srcaeinst(::std::string* srcaeinst) {
  if (srcaeinst_ != &::google::protobuf::internal::kEmptyString) {
    delete srcaeinst_;
  }
  if (srcaeinst) {
    set_has_srcaeinst();
    srcaeinst_ = srcaeinst;
  } else {
    clear_has_srcaeinst();
    srcaeinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srcAEName = 24;
inline bool CDAPMessage::has_srcaename() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CDAPMessage::set_has_srcaename() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CDAPMessage::clear_has_srcaename() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CDAPMessage::clear_srcaename() {
  if (srcaename_ != &::google::protobuf::internal::kEmptyString) {
    srcaename_->clear();
  }
  clear_has_srcaename();
}
inline const ::std::string& CDAPMessage::srcaename() const {
  return *srcaename_;
}
inline void CDAPMessage::set_srcaename(const ::std::string& value) {
  set_has_srcaename();
  if (srcaename_ == &::google::protobuf::internal::kEmptyString) {
    srcaename_ = new ::std::string;
  }
  srcaename_->assign(value);
}
inline void CDAPMessage::set_srcaename(const char* value) {
  set_has_srcaename();
  if (srcaename_ == &::google::protobuf::internal::kEmptyString) {
    srcaename_ = new ::std::string;
  }
  srcaename_->assign(value);
}
inline void CDAPMessage::set_srcaename(const char* value, size_t size) {
  set_has_srcaename();
  if (srcaename_ == &::google::protobuf::internal::kEmptyString) {
    srcaename_ = new ::std::string;
  }
  srcaename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_srcaename() {
  set_has_srcaename();
  if (srcaename_ == &::google::protobuf::internal::kEmptyString) {
    srcaename_ = new ::std::string;
  }
  return srcaename_;
}
inline ::std::string* CDAPMessage::release_srcaename() {
  clear_has_srcaename();
  if (srcaename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcaename_;
    srcaename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_srcaename(::std::string* srcaename) {
  if (srcaename_ != &::google::protobuf::internal::kEmptyString) {
    delete srcaename_;
  }
  if (srcaename) {
    set_has_srcaename();
    srcaename_ = srcaename;
  } else {
    clear_has_srcaename();
    srcaename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srcApInst = 25;
inline bool CDAPMessage::has_srcapinst() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CDAPMessage::set_has_srcapinst() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CDAPMessage::clear_has_srcapinst() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CDAPMessage::clear_srcapinst() {
  if (srcapinst_ != &::google::protobuf::internal::kEmptyString) {
    srcapinst_->clear();
  }
  clear_has_srcapinst();
}
inline const ::std::string& CDAPMessage::srcapinst() const {
  return *srcapinst_;
}
inline void CDAPMessage::set_srcapinst(const ::std::string& value) {
  set_has_srcapinst();
  if (srcapinst_ == &::google::protobuf::internal::kEmptyString) {
    srcapinst_ = new ::std::string;
  }
  srcapinst_->assign(value);
}
inline void CDAPMessage::set_srcapinst(const char* value) {
  set_has_srcapinst();
  if (srcapinst_ == &::google::protobuf::internal::kEmptyString) {
    srcapinst_ = new ::std::string;
  }
  srcapinst_->assign(value);
}
inline void CDAPMessage::set_srcapinst(const char* value, size_t size) {
  set_has_srcapinst();
  if (srcapinst_ == &::google::protobuf::internal::kEmptyString) {
    srcapinst_ = new ::std::string;
  }
  srcapinst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_srcapinst() {
  set_has_srcapinst();
  if (srcapinst_ == &::google::protobuf::internal::kEmptyString) {
    srcapinst_ = new ::std::string;
  }
  return srcapinst_;
}
inline ::std::string* CDAPMessage::release_srcapinst() {
  clear_has_srcapinst();
  if (srcapinst_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcapinst_;
    srcapinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_srcapinst(::std::string* srcapinst) {
  if (srcapinst_ != &::google::protobuf::internal::kEmptyString) {
    delete srcapinst_;
  }
  if (srcapinst) {
    set_has_srcapinst();
    srcapinst_ = srcapinst;
  } else {
    clear_has_srcapinst();
    srcapinst_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string srcApName = 26;
inline bool CDAPMessage::has_srcapname() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CDAPMessage::set_has_srcapname() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CDAPMessage::clear_has_srcapname() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CDAPMessage::clear_srcapname() {
  if (srcapname_ != &::google::protobuf::internal::kEmptyString) {
    srcapname_->clear();
  }
  clear_has_srcapname();
}
inline const ::std::string& CDAPMessage::srcapname() const {
  return *srcapname_;
}
inline void CDAPMessage::set_srcapname(const ::std::string& value) {
  set_has_srcapname();
  if (srcapname_ == &::google::protobuf::internal::kEmptyString) {
    srcapname_ = new ::std::string;
  }
  srcapname_->assign(value);
}
inline void CDAPMessage::set_srcapname(const char* value) {
  set_has_srcapname();
  if (srcapname_ == &::google::protobuf::internal::kEmptyString) {
    srcapname_ = new ::std::string;
  }
  srcapname_->assign(value);
}
inline void CDAPMessage::set_srcapname(const char* value, size_t size) {
  set_has_srcapname();
  if (srcapname_ == &::google::protobuf::internal::kEmptyString) {
    srcapname_ = new ::std::string;
  }
  srcapname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_srcapname() {
  set_has_srcapname();
  if (srcapname_ == &::google::protobuf::internal::kEmptyString) {
    srcapname_ = new ::std::string;
  }
  return srcapname_;
}
inline ::std::string* CDAPMessage::release_srcapname() {
  clear_has_srcapname();
  if (srcapname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcapname_;
    srcapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_srcapname(::std::string* srcapname) {
  if (srcapname_ != &::google::protobuf::internal::kEmptyString) {
    delete srcapname_;
  }
  if (srcapname) {
    set_has_srcapname();
    srcapname_ = srcapname;
  } else {
    clear_has_srcapname();
    srcapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resultReason = 27;
inline bool CDAPMessage::has_resultreason() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CDAPMessage::set_has_resultreason() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CDAPMessage::clear_has_resultreason() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CDAPMessage::clear_resultreason() {
  if (resultreason_ != &::google::protobuf::internal::kEmptyString) {
    resultreason_->clear();
  }
  clear_has_resultreason();
}
inline const ::std::string& CDAPMessage::resultreason() const {
  return *resultreason_;
}
inline void CDAPMessage::set_resultreason(const ::std::string& value) {
  set_has_resultreason();
  if (resultreason_ == &::google::protobuf::internal::kEmptyString) {
    resultreason_ = new ::std::string;
  }
  resultreason_->assign(value);
}
inline void CDAPMessage::set_resultreason(const char* value) {
  set_has_resultreason();
  if (resultreason_ == &::google::protobuf::internal::kEmptyString) {
    resultreason_ = new ::std::string;
  }
  resultreason_->assign(value);
}
inline void CDAPMessage::set_resultreason(const char* value, size_t size) {
  set_has_resultreason();
  if (resultreason_ == &::google::protobuf::internal::kEmptyString) {
    resultreason_ = new ::std::string;
  }
  resultreason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CDAPMessage::mutable_resultreason() {
  set_has_resultreason();
  if (resultreason_ == &::google::protobuf::internal::kEmptyString) {
    resultreason_ = new ::std::string;
  }
  return resultreason_;
}
inline ::std::string* CDAPMessage::release_resultreason() {
  clear_has_resultreason();
  if (resultreason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resultreason_;
    resultreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CDAPMessage::set_allocated_resultreason(::std::string* resultreason) {
  if (resultreason_ != &::google::protobuf::internal::kEmptyString) {
    delete resultreason_;
  }
  if (resultreason) {
    set_has_resultreason();
    resultreason_ = resultreason;
  } else {
    clear_has_resultreason();
    resultreason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 version = 28;
inline bool CDAPMessage::has_version() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CDAPMessage::set_has_version() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CDAPMessage::clear_has_version() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CDAPMessage::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::int64 CDAPMessage::version() const {
  return version_;
}
inline void CDAPMessage::set_version(::google::protobuf::int64 value) {
  set_has_version();
  version_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace googleprotobuf
}  // namespace impl
}  // namespace cdap
}  // namespace rina

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rina::cdap::impl::googleprotobuf::opCode_t>() {
  return ::rina::cdap::impl::googleprotobuf::opCode_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rina::cdap::impl::googleprotobuf::flagValues_t>() {
  return ::rina::cdap::impl::googleprotobuf::flagValues_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rina::cdap::impl::googleprotobuf::authTypes_t>() {
  return ::rina::cdap::impl::googleprotobuf::authTypes_t_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CDAP_2eproto__INCLUDED
